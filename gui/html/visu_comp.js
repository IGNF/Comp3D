/**
 * Copyright (c) Institut national de l'information géographique et forestière https://www.ign.fr/
 *
 * File main authors:
 *  - JM Muller
 *  - S Gonnet
 *  - P Bouquet
 *
 * This file is part of Comp3D: https://github.com/IGNF/Comp3D
 *
 * Comp3D is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 * Comp3D is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty
 * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 * You should have received a copy of the GNU General Public License along with Comp3D. If not, see <https://www.gnu.org/licenses/>.
 */

const translation_fr={
    " including ": " dont ",
    " on point ": " sur le point ",
    " redundant ": " redondantes ",
    " simulations:": " simulations :",
    "!": " !",
    "0%: essential observation / 100%: unnecessary observation": "0% : observation indispensable / 100% : observation inutile",
    "1/2 Axis (mm)": "1/2 Axe (mm)",
    ":": " :",
    ": ": " : ",
    "A posteriori \u03C3": "\u03C3 a posteriori",
    "Abscissa": "Abscisse",
    "Absolute \u03C3 + relative \u03C3": "\u03C3 absolu + \u03C3 relatif",
    "Active obs": "Obs actives",
    "Active observations number": "Nombre d'observations actives",
    "Active observations number linked to the point": "Nombre d'observations actives en lien avec le point",
    "Additional iteration number after convergence": "Nombre d&apos;itérations supplémentaires après convergence",
    "Additional iterations": "Itérations supplémentaires",
    "All residuals": "Tous les résidus",
    "Angle between vertical and sub-frame z": "Angle entre la verticale et l'axe z du sous-repère",
    "Average distance-relative normalized absolute residuals distribution": "Distribution des résidus absolus moyens par rapport à la distance",
    "Axes": "Axes",
    "Axis": "Axe",
    "Axis parameterization": "Paramétrage de l'axe",
    "Azimuth (gr)": "Azimut (gr)",
    "Back to top": "Retour en haut",
    "Big": "Gros",
    "Biggest ellipsoid semi axis:": "Plus gros demi-axe d'ellipsoide :",
    "Biggest residuals": "Plus gros résidus",
    "Cartesian global to Geocentric:": "Cartésiennes globales vers géocentriques :",
    "Center latitude": "Latitude centrale",
    "Click to fold/unfold": "Cliquer pour plier/déplier",
    "Code": "Code",
    "Commit: ": "Commit : ",
    "Comp": "Comp",
    "Compensated coordinates": "Coordonnées compensées",
    "Compensation": "Compensation",
    "Compensation done": "Compensation effectuée",
    "Computation duration": "Durée du calcul",
    "Computation information": "Informations sur le calcul",
    "Computation interruption": "Interruption du calcul",
    "Computation nature": "Type de calcul",
    "Computation start": "Début du calcul",
    "Conf": "Conf",
    "Confidence ellipsoids": "Ellipsoïdes de confiance",
    "Confidence semi-intervals": "Demi-intervalles de confiance",
    "Confidence: ": "Confiance : ",
    "Convergence criterion": "Critère de convergence",
    "Coord var/covar file": "Fichier var/covar des coordonnées",
    "DMS": "DMS",
    "Decimal places number": "Nombre de décimales",
    "Deflection": "Déviation",
    "Deg": "Degrés",
    "Degrees of freedom: ": "Degrés de liberté : ",
    "Description": "Description",
    "Difference between adjusted and measured observations": "Écart entre l\u0027observation compensée et l\u0027observation mesurée",
    "Disp": "Disp",
    "Distance": "Distance",
    "Distance between adjusted coordinates of the two points": "Distance entre les coordonnées compensées des 2 points",
    "Eh": "He",
    "Ell": "Ell",
    "Ellipsoidal heights": "En hauteurs ellipsoïdales",
    "Equality": "Égalité",
    "Equality constraints": "Constraintes d'égalité",
    "Export table": "Exporter le tableau",
    "File name": "Nom fichier",
    "For ": "Pour ",
    "From": "De",
    "G0": "G0",
    "Geocent def": "Def proj géocentrique",
    "Georeferencing": "Georéférencement",
    "Gh": "Alti",
    "Global cartesian coordinates": "Coordonnées cartésiennes globales",
    "Grad": "Grades",
    "Hide computation configuration messages": "Masquer les messages lors du paramétrage du calcul",
    "Hide computation messages": "Masquer les messages lors du calcul",
    "Hide configuration file reading messages": "Masquer les messages lors de la lecture de la configuration",
    "Hide file reading messages": "Masquer les messages lors de la lecture des fichiers",
    "Hide suggestions per file": "Cacher les suggestions par fichier",
    "Info": "Info",
    "Init": "Init",
    "Initial coordinates": "Coordonnées initiales",
    "Inter": "Inter",
    "Internal constraints": "Contraintes internes",
    "Internal reliability : value of the biggest not detectable error": "Fiabilité interne : valeur de la plus grande faute non détectable",
    "Is subframe z forced to be aligned with vertical?": "Est-ce que le z du sous-repère est contraint à la verticale ?",
    "Iteration": "Iteration",
    "Iterations": "Itérations",
    "LatLong def": "Def proj géographique",
    "Latitude to determine the local curvature of the ellipsoid": "Latitude permettant de déterminer la courbure locale de l'ellipsoïde",
    "Local coordinates center": "Centre des coordonnées locales",
    "MSE X (mm)": "EMQ X (mm)",
    "MSE Y (mm)": "EMQ Y (mm)",
    "MSE Z (mm)": "EMQ Z (mm)",
    "Max X (mm)": "Max X (mm)",
    "Max Y (mm)": "Max Y (mm)",
    "Max Z (mm)": "Max Z (mm)",
    "Maximum iterations": "Itérations maximum",
    "Measure": "Mesure",
    "Measure provenance": "Provenance de la mesure",
    "Monte-Carlo Simulation": "Simulation Monte-Carlo",
    "Monte-Carlo simulation done": "Simulation de Monte-Carlo effectuée",
    "Name": "Nom",
    "No": "Non",
    "No big residuals": "Pas de gros résidus",
    "Non-initialisable points": "Points non initialisables",
    "Normal matrix inversion": "Inversion de la matrice normale",
    "Normalized residual": "Résidu normalisé",
    "Normalized residuals distribution": "Répartition des résidus normalisés",
    "Not enough observations": "Pas assez d'observations",
    "Not enough redundancy": "Pas assez de redondance",
    "Not verticalized": "Non verticalisé",
    "Number and nature of active observations": "Nombre et nature des observations actives",
    "Obs": "Obs",
    "Observation": "Observation",
    "Observation \u03C3 after adjusted": "\u03C3 sur l\u0027observation obtenue après compensation",
    "Observation number of this type: ": "Nombre d'observations de ce type : ",
    "Observation type": "Type d'observation",
    "Observations": "Observations",
    "Observations number minus parameters number": "Nombre d'observations actives moins nombre de paramètres",
    "Observations sigmas may be multiplied by:": "Il faudrait mutiplier les sigmas des observations par :",
    "Only impacts vertical angle measures": "N'affecte que les mesures zénithales",
    "Options: ": "Options : ",
    "Origin point": "Point origine",
    "Parameters": "Paramètres",
    "Partial redundancies average of this type: ": "Moyenne des redondances partielles de ce type : ",
    "Point": "Point",
    "Points displacements simulation": "Simulation des déplacements des points",
    "Positions": "Positions",
    "Probable error": "Faute probable",
    "Probable error value \n Display if standardized residual > 2.5": "Valeur de la faute probable \n Affichée si résidu normé > 2.5",
    "Project configuration": "Configuration du chantier",
    "Projection center": "Centre de la projection",
    "Projection definition": "Définition projection",
    "Projection name": "Nom projection",
    "Propagation Simulation": "Simulation par propagation",
    "Rad": "Radians",
    "Radius": "Rayon",
    "Rank default": "Défaut de rang",
    "Redondancy": "Redondance",
    "Ref": "Ref",
    "Refraction coefficient": "Coefficient de réfraction",
    "Required to get confidence intervals and ellipsoids and get redondancy informations": "Nécessaire pour obtenir des intervalles et ellipsoïdes de confiance et obtenir les informations de redondance",
    "Res": "Rés",
    "Residual": "Résidu",
    "Residual distribution": "Répartition des résidus",
    "Residual divided by a posteriori \u03C3": "Résidu divisé par le \u03C3 a posteriori",
    "Residual divided by its precision": "Résidu divisé par sa précision",
    "Residual divided by total \u03C3": "Résidu divisé par le \u03C3 total",
    "Residual in the measure unit": "Résidu dans l\u0027unité de la mesure",
    "Residual mm": "Résidu mm",
    "Root COR file": "Fichier COR racine",
    "Root OBS file": "Fichier OBS racine",
    "Select table": "Sélectionner le tableau",
    "Show computation configuration messages": "Afficher les messages lors du paramétrage du calcul",
    "Show computation messages": "Afficher les messages lors du calcul",
    "Show configuration file reading messages": "Afficher les messages lors de la lecture de la configuration",
    "Show file reading messages": "Afficher les messages lors de la lecture des fichiers",
    "Show suggestions per file": "Afficher les suggestions par fichier",
    "Sim": "Sim",
    "Similarities": "Bascules",
    "Solver name": "Nom solveur",
    "Sphere radius": "Rayon de la sphère",
    "Standard": "Standard",
    "Standard residual": "Résidu standard",
    "Standardized residual": "Résidu normé",
    "Station": "Station",
    "Stereo def": "Def proj stéréographique",
    "Sugg": "Sugg",
    "Suggestions": "Suggestions",
    "Sum of partial redundancies corresponding to the degree of freedom of the system": "Somme des redondances partielles correspondant au degré de liberté du système",
    "Sum of partial redundancies of this type: ": "Somme des redondances partielles de ce type : ",
    "System redundancy": "Redondance du système",
    "Table selected! CTRL+C to copy": "Tableau sélectionné ! CTRL+C pour copier",
    "Target": "Cible",
    "Target ID": "ID cible",
    "Targeted point": "Point visé",
    "Test passed: ": "Test réussi : ",
    "Test: ": "Test : ",
    "The partial redundancies average of this type is less than 30%": "La moyenne des redondances partielles de ce type est inférieure à 30%",
    "Tilt (gr)": "Site (gr)",
    "To": "Vers",
    "Total \u03C3": "\u03C3 total",
    "Total observations number": "Nombre d'observations total",
    "Tour number": "Numéro tour",
    "Transformation between subframe and global cartesian frame": "Transformation entre le sous-repère et le repère cartésien global",
    "Type": "Type",
    "Type-based normalized residuals distribution": "Répartition des résidus normalisés par type",
    "Unit": "Unité",
    "User proj def": "Def proj utilisateur",
    "Using vertical deflection": "Avec déviation de la verticale",
    "Value": "Valeur",
    "Version: ": "Version : ",
    "Vertical": "Verticale",
    "Vertical deflection south-north in arc seconds": "Déviation de la verticale sud-nord en secondes d'arc",
    "Vertical deflection west-east in arc seconds": "Déviation de la verticale ouest-est en secondes d'arc",
    "Verticalized": "Verticalisé",
    "Without file": "Sans fichier",
    "Yes": "Oui",
    "\u0302\u03C3": "\u0302\u03C3",
    "\u0302\u03C3x (mm)": "\u0302\u03C3x (mm)",
    "\u0302\u03C3y (mm)": "\u0302\u03C3y (mm)",
    "\u0302\u03C3z (mm)": "\u0302\u03C3z (mm)",
    "\u03B7": "\u03B7",
    "\u03BE": "\u03BE",
    "\u03C30": "\u03C30",
    "\u03C30 difference between 2 iterations": "Différence de \u03C30 entre 2 itérations",
    "\u03C30 evolution": "Évolution du \u03C30",
    "\u03C30 final": "\u03C30 final",
    "\u03C30 initial": "\u03C30 initial",
    "\u03C7\u00B2": "\u03C7\u00B2",
    "\u03C7\u00B2 test": "Test du \u03C7²",
    "\u2207": "\u2207",
    "clue for the precision given in the report, some value are given with less or more decimal places": "c'est un indice de la précision donnée dans le rapport, certaines valeurs seront données avec plus ou moins de décimales",
    "of the total redundancy": "de la redondance totale",
    "reset sort": "ordre par défaut",
    "which correponds to": "soit",
}



//------------------------------------------------------------------------------
// begin simple_i18n functions
//------------------------------------------------------------------------------
const translations = {
    // update list of translations here, example: "fr":translation_fr,
    "fr": translation_fr,
};
//choose the translation here
var current_dict = {};
function _(key){
  if (key in current_dict)
    return current_dict[key]
  return key;
}
// end simple_i18n functions

//------------------------------------------------------------------------------
// Variables declaration
//------------------------------------------------------------------------------
const codes_obs = {
  "-1": "crd_x",
  "-2": "crd_y",
  "-3": "crd_z",
  "1": "dist",
  "2": "dist hz0",
  "3": "dist",
  "4": "den",
  "5": "hz",
  "6": "zen",
  "7": "open",
  "8": "azim",
  "9": "center_meta",
  "10": "photo",
  "11": "scanner",
  "12": "tracker",
  "13": "align",
  "14": "dE",
  "15": "dN",
  "18": "axis",
  "21": "eq dh",
  "22": "eq dist",
  "91": "center_x",
  "92": "center_y",
  "101": "bascule_x",
  "102": "bascule_y",
  "103": "bascule_z",
  "104": "bascule_hz",
  "105": "bascule_zen",
  "106": "bascule_dist",
  "107": "bl_x",
  "108": "bl_y",
  "109": "bl_z",
  "181": "axe_r",
  "182": "axe_l",
  "184": "axe_c",
  "187": "axe_fx",
  "188": "axe_fy",
  "189": "axe_fz",
  "201": "cint_tx",
  "202": "cint_ty",
  "203": "cint_tz",
  "204": "cint_rx",
  "205": "cint_ry",
  "206": "cint_rz",
  "207": "cint_sc",
};

const type_obs = {
  1 : "dist",
  2 : "dist",
  3 : "dist",
  4 : "den",
  5 : "hz",
  7 : "hz",
  8 : "hz",
  6 : "zen",
  14 : "dEN",
  15 : "dEN",
  21 : "eq dh",
  22 : "eq dist",
  101 : "basc",
  102 : "basc",
  103 : "basc",
  104 : "basc",
  105 : "basc",
  106 : "basc",
  107 : "bl",
  108 : "bl",
  109 : "bl",
  181 : "axis",
  182 : "axis",
  183 : "axis",
  184 : "axis",
  185 : "axis",
  186 : "axis",
  187 : "axis",
  188 : "axis",
  189 : "axis",
  "-1" : "coord",
  "-2" : "coord",
  "-3" : "coord",
  201 : "cint",
  202 : "cint",
  203 : "cint",
  204 : "cint",
  205 : "cint",
  206 : "cint",
  207 : "cint",
};

var title = "?";

//variables to know if obs type exist for graph
var exist = {};
for (let code in type_obs){
  exist[type_obs[code]] = false;
}
var exist_type=[];
var three_dimension=false;

const src_link = "https://github.com/IGNF/Comp3D";
const fill_fold = "||";
const parite = ["paire", ""];
const max_biggest_residuals = 20;
//Step for residual ananlysis
const first_step_standardized_residual=2.5
const second_step_standardized_residual=4.1
const first_step_normalized_residual=3
const second_step_normalized_residual=6
const type_dist_chart=["dist","hz","zen","basc","bl"];
var nb_decimals;
var nb_decimals_mini;
var all_pts = [];
var nb_pts;
var all_pts_name = {};
var all_files = [];
var all_obs = [];
var all_g0 = [];
var all_basc = [];
var all_axes = [];
var all_eq = [];
var all_active_obs = [];

//translation in calling : if not, not work
const full_name_type = {
  "dist": 'Distances',
  "hz": 'Horizontal angles',
  "zen" :  'Zenith angles',
  "den" : 'Direct levelling',
  "coord" : 'Coordinates',
  "basc" : 'Similarities',
  "axis" : 'Axes',
  "bl" : 'GNSS baseline',
  "dEN" : 'Centering',
  "eq dh" : 'Equal dH',
  "eq dist" : 'Equal dist',
};

const bgColor = {//background color
    "std" : "rgba(120,120,120,1)",
    "all" : "rgba(255,162,0,1)",
    "hz" : "rgba(0,180,180,1)",
    "zen" : "rgba(0,220,0,1)",
    "dist" : "rgba(0,0,220,1)",
    "basc" : "rgba(255,204,204,1)",
    "bl" : "rgba(180,0,30,1)",
    "axis" : "rgba(200,0,200,1)",
    "coord" : "rgba(200,200,0,1)",
    "den" : "rgba(255,215,0,1)",
    "dEN" : "rgba(255,228,181,1)",
    "eq dh" : "rgba(255,120,81,1)",
    "eq dist" : "rgba(255,81,120,1)",
}
const bdColor = {//border color
    "std" : "rgba(120,120,120,1)",
    "all" : "rgba(255,162,0,1)",
    "hz" : "rgba(100,180,180,1)",
    "zen" : "rgba(100,220,100,1)",
    "dist" : "rgba(100,100,220,1)",
    "basc" : "rgba(255,224,224,1)",
    "bl" : "rgba(180,100,30,1)",
    "axis" : "rgba(200,100,220,1)",
    "coord" : "rgba(200,200,100,1)",
    "den" : "rgba(255,215,0,1)",
    "dEN" : "rgba(255,228,181,1)",
    "eq dh" : "rgba(255,120,81,1)",
    "eq dist" : "rgba(255,81,120,1)",
}

//global for map
let mymap;
let minx;
let miny;
let maxx;
let maxy;


function to_fixed(val, digits) {
    try {
        return val.toFixed(digits);
    } catch (error) {
      if (error instanceof RangeError) return to_fixed(val, 1);
      return "NaN";
    }
}

function get_header_conf(table_name, matrix_inverted,use_vertical_deflection,compute_type=0){
    let header_conf = []
    if(table_name === "observations" || table_name === "biggest_residuals"){
        header_conf.push(
            {displayed_name:"index_init", field:"index_init", tooltip:"", sortable:true, fixed_dec:false, foldable:false});
        if (table_name === "biggest_residuals")
            header_conf.push(
                {displayed_name:"", field:"href_obs", tooltip:"", sortable:false, fixed_dec:false, foldable:false});
        else
            header_conf.push(
                {displayed_name:_("Active"), field:"active", tooltip:_("Activate or desactivate observation"), sortable:true, fixed_dec:false, foldable:false});
        header_conf.push(
            {displayed_name:_("Code"), field:"code", tooltip:_("Observation type"), fixed_dec:false, sortable:true, foldable:false },
            {displayed_name:_("From"), field:"from", tooltip:_("Measure provenance"), fixed_dec:false, sortable:true, foldable:false },
            {displayed_name:_("To"), field:"to", tooltip:_("Targeted point"), fixed_dec:false, sortable:true, foldable:false },
            {displayed_name:_("Observation"), field:"original_value", tooltip:_("Measure"), fixed_dec:true, sortable:true, foldable:false },
            {displayed_name:_("Distance"), field:"obs_length", tooltip:_("Distance between adjusted coordinates of the two points"),fixed_dec:true, sortable:true, foldable:false },
            {displayed_name:_("Total \u03C3"), field:"sigma_total", tooltip:_("Absolute \u03C3 + relative \u03C3"), fixed_dec:true, sortable:true, foldable:true }
        )
        if (!(compute_type===2)){//No Monte-Carlo
          header_conf.push(
            {displayed_name:_("Normalized residual"), field:"normalized_residual", tooltip:_("Residual divided by total \u03C3"), fixed_dec:true, sortable:true, foldable:true },
            {displayed_name:_("Residual"), field:"residual", tooltip:_("Residual in the measure unit"), fixed_dec:true, sortable:true, foldable:true },
            {displayed_name:_("Residual mm"), field:"residual_mm", tooltip:_("Difference between adjusted and measured observations"), fixed_dec:true, sortable:true, foldable:true }
          );
        }
        if (matrix_inverted)
          header_conf.push(
            {displayed_name:_("A posteriori \u03C3"), field:"sigma_a_posteriori", tooltip:_("Observation \u03C3 after adjusted"), fixed_dec:true, sortable:true, foldable:true },
            {displayed_name:_("Standard residual"), field:"residual_std", tooltip:_("Residual divided by a posteriori \u03C3"), fixed_dec:true, sortable:true, foldable:true },
            {displayed_name:_("Standardized residual"), field:"standardized_residual", tooltip:_("Residual divided by its precision"), fixed_dec:true, sortable:true, foldable:true },
            {displayed_name:_("Redondancy"), field:"obs_redondancy", tooltip:_("0%: essential observation / 100%: unnecessary observation"), fixed_dec:true, sortable:true, foldable:true },
            {displayed_name:_("\u2207"), field:"nabla", tooltip:_("Internal reliability : value of the biggest not detectable error"), fixed_dec:true, sortable:true, foldable:true },
            {displayed_name:_("Probable error"), field:"probable_error", tooltip:_("Probable error value \n Display if standardized residual > 2.5"), fixed_dec:true, sortable:true, foldable:true }
          );
        return header_conf

    }else if(table_name === "init_coord"){
        let component = get_component();
        header_conf.push(
            {displayed_name:"index_init", field:"index_init", tooltip:"", sortable:true, fixed_dec:false, foldable:false},
            {displayed_name:_("Name"), field:"name", tooltip:"", sortable:true, fixed_dec:false, foldable:false},
            {displayed_name:component[0]+" init", field:"x_init", tooltip:"", sortable:true, fixed_dec:false, foldable:false},
            {displayed_name:component[1]+" init", field:"y_init", tooltip:"", sortable:true, fixed_dec:false, foldable:false},
            {displayed_name:component[2]+" init", field:"z_init", tooltip:"", sortable:true, fixed_dec:false, foldable:false}
        )
        if (three_dimension){
            header_conf.push(
                {displayed_name:"\u03C3x init", field:"sigma_x_init", tooltip:"", sortable:true, fixed_dec:false, foldable:false},
                {displayed_name:"\u03C3y init", field:"sigma_y_init", tooltip:"", sortable:true, fixed_dec:false, foldable:false}
            )
        }
        header_conf.push(
            {displayed_name:"\u03C3z init", field:"sigma_z_init", tooltip:"", sortable:true, fixed_dec:false, foldable:false}
        )
        if(use_vertical_deflection)
            header_conf.push(
                {displayed_name:_("\u03B7"), field:"dev_eta", tooltip:_('Vertical deflection west-east in arc seconds'), sortable:true, fixed_dec:false, foldable:false},
                {displayed_name:_("\u03BE"), field:"dev_xi", tooltip:_('Vertical deflection south-north in arc seconds'), sortable:true, fixed_dec:false, foldable:false}
            );

        header_conf.push(
            {displayed_name:_("Active obs"), field:"active_obs", tooltip:_('Active observations number linked to the point'), sortable:true, fixed_dec:false, foldable:false}
        );

        return header_conf
    }else if(table_name === "g0s"){
      header_conf.push(
        {displayed_name:_("Point"), field:"point", tooltip:"", sortable:true, fixed_dec:false, foldable:false},
        {displayed_name:_("Tour number") , field:"num", tooltip:"", sortable:true, fixed_dec:false, foldable:false},
        {displayed_name:_("Value"), field:"value", tooltip:"", sortable:true, fixed_dec:false, foldable:false},
        {displayed_name:_("\u0302\u03C3"), field:"sigma", tooltip:"", sortable:true, fixed_dec:false, foldable:false},
        {displayed_name:_("Active obs"), field:"active_obs", tooltip:"", sortable:true, fixed_dec:false, foldable:false},
      );
      return header_conf
    }else if(table_name === "equalities"){
      header_conf.push(
        {displayed_name:_("File name"), field:"file_name", tooltip:"", sortable:true, fixed_dec:false, foldable:false},
        {displayed_name:_("Type") , field:"type", tooltip:"", sortable:true, fixed_dec:false, foldable:false},
        {displayed_name:_("Value"), field:"value", tooltip:"", sortable:true, fixed_dec:false, foldable:false},
        {displayed_name:_("\u0302\u03C3"), field:"sigma", tooltip:"", sortable:true, fixed_dec:false, foldable:false},
        {displayed_name:_("Active obs"), field:"active_obs", tooltip:"", sortable:true, fixed_dec:false, foldable:false},
      );
      return header_conf
    }else if(table_name === "similarities"){
      header_conf.push(
        {displayed_name:_("File name"), field:"file_name", tooltip:"", sortable:false, fixed_dec:false, foldable:false},
        {displayed_name:_("Origin point") , field:"origin_point", tooltip:"", sortable:false, fixed_dec:false, foldable:false},
        {displayed_name:_("Vertical"), field:"vertical", tooltip:"", sortable:false, fixed_dec:false, foldable:false},
        {displayed_name:_("Global cartesian coordinates") + "(m)", field:"glob_cart_coord", tooltip:"", sortable:false, fixed_dec:false, foldable:false, colspan: "4"},
      );
      if (matrix_inverted)
        header_conf.push(
          {displayed_name:_("Sigmas"), field:"sigmas", tooltip:"", sortable:false, fixed_dec:false, foldable:false},
        );
      return header_conf
    }else if(table_name === "coord_comp_table"){
        let component = get_component();

        var coord_compensated = "georef";

        header_conf.push(
            {displayed_name:"index_init", field:"index_init", tooltip:"", sortable:true, fixed_dec:false, foldable:false},
            {displayed_name:_("Name"), field:"name", tooltip:"", sortable:true, fixed_dec:false, foldable:false},
            {displayed_name:component[0] + " comp", field:"x_comp", tooltip:"", sortable:true, fixed_dec:true, foldable:false, coord:coord_compensated},
            {displayed_name:component[1] + " comp", field:"y_comp", tooltip:"", sortable:true, fixed_dec:true, foldable:false, coord:coord_compensated},
            {displayed_name:component[2] + " comp", field:"z_comp", tooltip:"", sortable:true, fixed_dec:true, foldable:false, coord:coord_compensated}
        )
        if (three_dimension){
            header_conf.push(
                {displayed_name:"\u0394" + component[0], field:"x_shift", tooltip:"", sortable:true, fixed_dec:true, foldable:true},
                {displayed_name:"\u0394" + component[1], field:"y_shift", tooltip:"", sortable:true, fixed_dec:true, foldable:true}
            )
        }
        header_conf.push(
            {displayed_name:"\u0394" + component[2], field:"z_shift", tooltip:"", sortable:true, fixed_dec:true, foldable:true}
        )
        if (three_dimension){
            header_conf.push(
                {displayed_name:"\u03C3x init", field:"sigma_x_init", tooltip:"", sortable:true, fixed_dec:true, foldable:true},
                {displayed_name:"\u03C3y init", field:"sigma_y_init", tooltip:"", sortable:true, fixed_dec:true, foldable:true}
            )
        }
        header_conf.push(
            {displayed_name:"\u03C3z init", field:"sigma_z_init", tooltip:"", sortable:true, fixed_dec:true, foldable:true}
            );

        if(use_vertical_deflection){
            header_conf.push(
                {displayed_name:_("\u03B7"), field:"dev_eta", tooltip:_("Vertical deflection west-east in arc seconds"), sortable:true, fixed_dec:true, foldable:true},
                {displayed_name:_("\u03BE"), field:"dev_xi", tooltip:_("Vertical deflection south-north in arc seconds"), sortable:true, fixed_dec:true, foldable:true}
            );
        }

        header_conf.push(
           {displayed_name:_("Active obs"), field:"active_obs", tooltip:_("Active observations number linked to the point"), sortable:true, fixed_dec:false, foldable:true}
                    );
        return header_conf

    }else if(table_name === "ellips"){
       header_conf.push(
        {displayed_name:_("Name"), field:"name", tooltip:"", sortable:false, fixed_dec:false, foldable:false},
        {displayed_name:_("1/2 Axis (mm)"), field:"semi-axis", tooltip:"", sortable:false, fixed_dec:false, foldable:false},
        {displayed_name:_("Azimuth (gr)"), field:"azim", tooltip:"", sortable:false, fixed_dec:false, foldable:false},
        {displayed_name:_("Tilt (gr)"), field:"tilt", tooltip:"", sortable:false, fixed_dec:false, foldable:false},

       );
        return header_conf;

    }else if(table_name === "interv"){
        header_conf.push(
            {displayed_name:"index_init", field:"index_init", tooltip:"", sortable:true, fixed_dec:false, foldable:false},
            {displayed_name:_("Name"), field:"name", tooltip:"", sortable:true, fixed_dec:false, foldable:false}
        )
        if (three_dimension){
            header_conf.push(
                {displayed_name:_("\u0302\u03C3x (mm)"), field:"sigmax", tooltip:"", sortable:true, fixed_dec:false, foldable:false},
                {displayed_name:_("\u0302\u03C3y (mm)"), field:"sigmay", tooltip:"", sortable:true, fixed_dec:false, foldable:false}
            )
        }
        header_conf.push(
            {displayed_name:_("\u0302\u03C3z (mm)"), field:"sigmaz", tooltip:"", sortable:true, fixed_dec:false, foldable:false}
        );
         return header_conf;
    }else if(table_name === "displa"){
      header_conf.push(
        {displayed_name:"index_init", field:"index_init", tooltip:"", sortable:true, fixed_dec:false, foldable:false},
        {displayed_name:_("Name"), field:"name", tooltip:"", sortable:true, fixed_dec:false, foldable:false});
      if (three_dimension){
        header_conf.push(
          {displayed_name:_("MSE X (mm)"), field:"emqx", tooltip:"", sortable:true, fixed_dec:false, foldable:false},
          {displayed_name:_("MSE Y (mm)"), field:"emqy", tooltip:"", sortable:true, fixed_dec:false, foldable:false});
      }
      header_conf.push({displayed_name:_("MSE Z (mm)"), field:"emqz", tooltip:"", sortable:true, fixed_dec:false, foldable:false});
      if (three_dimension){
        header_conf.push(
          {displayed_name: _("Max X (mm)"), field:"maxx", tooltip:"", sortable:true, fixed_dec:false, foldable:false},
          {displayed_name: _("Max Y (mm)"), field:"maxy", tooltip:"", sortable:true, fixed_dec:false, foldable:false});
      }
      header_conf.push({displayed_name: _("Max Z (mm)"), field:"maxz", tooltip:"", sortable:true, fixed_dec:false, foldable:false});
      return header_conf;
    }else{
        return undefined;
    }
}

//------------------------------------------------------------------------------
// Sorting functions
//------------------------------------------------------------------------------
function get_cell_value(row, columnIndex){
  let td = row.cells[columnIndex];
  if (td){
    for (let i = 0; i < td.childNodes.length; ++i){
      if (td.childNodes[i].title == "true"){
        return 1;
      }else if (td.childNodes[i].title == "false"){
        return 0;
      }else if (td.childNodes[i].nodeType !== Node.TEXT_NODE){
        if (td.childNodes[i].classList.contains("value")){
          if (td.childNodes[i].innerText === '-'){
            return 10000;
          }else if(td.childNodes[i].innerText === ''){
            return 9999;
          }else{
            let val = parseFloat(Math.abs(td.childNodes[i].innerText));
            if(isNaN(val))
              return td.childNodes[i].innerText;
            else
              return val;
          }
        }
      }else{
        return td.innerText;
      }
    }
    return 10001;
  }else{
    return 10002;
  }
}

function remove_dir_attribute(th){
  let curr_index = parseInt(th.cellIndex);
  let tr = th.parentNode
  for (let i = 0; i < (tr.children.length ); i++) {
    if (i !== curr_index){ // except current th clicked
      tr.children[i].removeAttribute('sort_dir');
    }
  }
}

function get_sort_dir(th){
    let sort_dir = th.getAttribute('sort_dir');
    if (sort_dir === null || th.getAttribute('field') === 'index_init'){
        sort_dir = 'asc'
        th.setAttribute('sort_dir', 'asc');
    }else if (sort_dir === 'asc'){
        sort_dir = 'desc'
        th.setAttribute('sort_dir', 'desc');
    }else{
        sort_dir = 'asc'
        th.setAttribute('sort_dir', 'asc');
    }
    return sort_dir
}

function sort_table(th_clicked){

    let th = th_clicked
    let th_index = th.cellIndex;
    let table = th.closest('table');
    let tbody = table.tBodies[0];

    toggle_row_file(table.id, th_index)

    if (table && tbody) {
        remove_dir_attribute(th);
        let sort_dir = get_sort_dir(th);
        let reA = /[^a-zA-Z]/g;
        let reN = /[^0-9]/g;

        sortRows(tbody, function sortAlphaNum(row1,row2) {
            let o1 = get_cell_value(row1, th_index);
            let o2 = get_cell_value(row2, th_index);
            var AFloat = parseFloat(o1, 10);
            var BFloat = parseFloat(o2, 10);

            if(isNaN(AFloat) && isNaN(BFloat)){
                var aA = o1.replace(reA, "");
                var bA = o2.replace(reA, "");
                if(aA === bA) {
                    var aN = parseFloat(o1.replace(reN, ""), 10);
                    var bN = parseFloat(o2.replace(reN, ""), 10);
                    return aN === bN ? 0 : aN > bN ? 1 : -1;
                } else {
                    return aA > bA ? 1 : -1;
                }
            }else if(isNaN(AFloat)){    //A is not a float
                return 1;   //to make alphanumeric sort first return -1 here
            }else if(isNaN(BFloat)){    //B is not a float
                return -1;  //to make alphanumeric sort first return 1 here
            }else{
                return AFloat > BFloat ? 1 : -1;
            }
        }, sort_dir);
    }
}

function sortRows(tbody, compare, sort_dir){
    //convert html collection to array
    var rows = [].slice.call(tbody.rows);
    //sort to desired order
    rows.sort(compare);
    if (sort_dir === 'desc') {
        rows.reverse();
    }
    //update table
    var fragment = document.createDocumentFragment();
    rows.forEach(function (row) {
        fragment.appendChild(row);
    });
    tbody.appendChild(fragment);
}

function toggle_row_file(table_id, index){
  let row_file = document.querySelectorAll(`#${table_id} tr.filename`);
  for (let i=0;i<row_file.length;i++){
    let r=row_file[i];
    if (index === 0)
      r.classList.remove("hide_sorting")
    else
      r.classList.add("hide_sorting")
  }
}

function create_sort_reset_button(table_id){

    // Get the reference table
    let ref_table = document.querySelector(`#${table_id}`);
    // first_column = index_init
    let first_column =  document.querySelector(`#${table_id} th:first-child`);

    let reset_sort = document.createElement("div");

    reset_sort.innerHTML = ('&#8635;');
    reset_sort.classList.add('mouse_hand');
    reset_sort.classList.add('button');

    let tt = add_tooltip(_("reset sort"));
    reset_sort.appendChild(tt);

    reset_sort.addEventListener('click', function(){
        first_column.click();
    });

    return reset_sort
}
//------------------------------------------------------------------------------
// End Sorting functions
//------------------------------------------------------------------------------

function deletetooltip(table){//for table export
  let table_export = table.cloneNode(true);
  let tips = table_export.querySelectorAll(`.tooltip`);
  for (let i=0;i<tips.length;i++){
    let t=tips[i];
    t.innerHTML = "";
  }
  let folds = table_export.querySelectorAll(`.folded`);
  for (let j=0;j<folds.length;j++){
    let f=folds[j];
    f.innerHTML = "";
  }
  return table_export
}

function selectTable(table){
    var body = document.body, range, sel;

    if (document.createRange && window.getSelection) {
        range = document.createRange();
        sel = window.getSelection();
        sel.removeAllRanges();
        try {
            range.selectNodeContents(table);
            sel.addRange(range);
        } catch (e) {
            range.selectNode(table);
            sel.addRange(range);
        }
    } else if (body.createTextRange) {
        range = body.createTextRange();
        range.moveToElementText(table);
        range.select();
    }
    notify(_("Table selected! CTRL+C to copy"))
}

function exportAsSpreadsheet(tables_ids, name){
    var html = "<html><head><meta charset='utf-8' /></head><body>";
    let filename = name+".xls";

    tables_ids.forEach((table_id) =>{

        let table = document.querySelector(`#${table_id}`);

        let table2export = deletetooltip(table);
        html += "<br><br>" + table2export.outerHTML ;

        });

    html += "</body></html>";
    // Instantiate a Blob object. The first parameter of its constructor is an array containing file contents, and the second parameter is an object containing file type attributes
    var blob = new Blob([html], { type: "application/octet-stream" });

    const a = document.createElement('a');
    document.body.appendChild(a);
    const url = window.URL.createObjectURL(blob);
    a.href = url;
    a.download = filename;
    a.click();
    setTimeout(() => {
      window.URL.revokeObjectURL(url);
      document.body.removeChild(a);
    }, 0)
}

function create_select_button(table_id){

    let export_div = document.createElement("div");

    export_div.innerHTML = ('&#10697');;
    export_div.classList.add('mouse_hand');
    export_div.classList.add('button');


    let tt = add_tooltip(_("Select table"));
    export_div.appendChild(tt);

    export_div.onclick = function(){
        selectTable(document.querySelector(`#${table_id}`));
    };

    return export_div;
}

function create_export_button(tables_ids, name){

    let export_div = document.createElement("div");

    export_div.innerHTML = ('&#10515;');
    export_div.classList.add('mouse_hand');
    export_div.classList.add('button');


    let tt = add_tooltip(_("Export table"));
    export_div.appendChild(tt);

    export_div.onclick = function(){
        exportAsSpreadsheet(tables_ids, name);
    };

    return export_div;
}

function make_th_sortable(th){
    th.classList.add('mouse_hand');
    th.addEventListener('click',  function(){
        sort_table(this);
    });
    return th
}

//---------------------------------------------------------------------------------------
//--------------- Make an html header table
//---------------------------------------------------------------------------------------
function make_html_header(header_config){

    let thead = document.createElement("thead");
    let tr = document.createElement("tr");

    if (header_config !== undefined){
        header_config.forEach((col, index, array) => {
            let th = document.createElement("th");

            let span_value = document.createElement("span");
            span_value.classList.add("foldable");
            span_value.classList.add("value");

            let span_fold = document.createElement("span");
            span_fold.classList.add("foldable");
            span_fold.classList.add("folded");
            span_fold.innerHTML = fill_fold;

            th.title = col.tooltip;
            th.setAttribute("field", col.field);
            span_value.innerHTML = col.displayed_name

            th.appendChild(span_value);
            th.appendChild(span_fold);

            if (col.sortable)
                make_th_sortable(th);
            if (col.colspan){
                th.colSpan = col.colspan
             }

            tr.appendChild(th);

        });
    }
    thead.appendChild(tr);

    return thead
}

function format_value(val, abs, num_dec, attribute, active, foldable, style=null){
  let span_value = document.createElement("span");
  span_value.classList.add("value");
  if(style !== null)
    span_value.classList.add(style);
  if (val !== undefined){
    if (foldable)
      span_value.classList.add("foldable");
    if (num_dec === false){
      span_value.innerHTML = val;
    }else{
      if (abs){
        if (val === " " || val === "-"){
          span_value.innerHTML = val;
        }else{
          span_value.innerHTML = to_fixed(Math.abs(parseFloat(val)), num_dec);
        }
      }else{
        if (val === " " || val === "-"){
          span_value.innerHTML = val;
        }else{
          span_value.innerHTML = to_fixed(parseFloat(val), num_dec);
        }
      }
    }
    if (attribute)
      if (!(val === " " || val === "-")){
        span_value.setAttribute(attribute[0], attribute[1]);
      }
      return span_value;
  }else{
    if (foldable){
      span_value.classList.add("foldable");
    }
    if (active){
      span_value.innerHTML = "";
      return span_value;
    }else{
      span_value.innerHTML = "-";
      return span_value;
    }
  }
}

function toggle_fold_column(){

    var index = this.cellIndex

    let el = this;

    // Get table id
    while ((el = el.parentElement) && el.nodeName.toUpperCase() !== 'TABLE');
    let table_id = el.id;


    // Loop on j column table
    let all_td_index = document.querySelectorAll(`#${table_id} tr td:nth-child(${index+1})`);
    for (let j = 0; j< all_td_index.length; j++){
        let td_fold = all_td_index[j];

        for (let k = 0; k < td_fold.childNodes.length; k++) {
            if (td_fold.childNodes[k].nodeType !== Node.TEXT_NODE){
                if (td_fold.childNodes[k].classList.contains("foldable")) {
                   td_fold.childNodes[k].classList.toggle("folded");
                }
            }
        }
    }

    // Toggle m header table
    let headers = document.querySelectorAll(`#${table_id} tr th:nth-child(${index+1})`);
    for (let m = 0; m < headers[0].childNodes.length; m++) {
        if (headers[0].childNodes[m].classList.contains("foldable")) {
            headers[0].childNodes[m].classList.toggle("folded");
        }
    }
}

function add_dl_row(dlElement,dt_content,dd_content,dt_title=undefined,dd_class=undefined){//add row in enumeration for info_work and info_calc
  const dt=document.createElement("dt");
  dt.innerHTML=dt_content+ _(":");
  if (dt_title){
    dt.title=dt_title;
  }
  dlElement.appendChild(dt);
  const dd=document.createElement("dd");
  dd.innerHTML=dd_content;
  if (dd_class){
    dd.classList.add(dd_class);
  }
  dlElement.appendChild(dd);
  return dlElement;
}

function add_pt_row(columns, pt, index_init){
    let new_tr = document.createElement("tr");
    let pt_code = pt_code_name2html(pt.code_name);
    let coord = pt.coord_compensated_georef;

    columns.forEach((col, index, array) => {
        let td = document.createElement("td");
        let val = pt[col.field];
        let comment_tooltip;
        let shift = "-";
        let sigma = "-";
        let style = null;
        if(col.foldable)
            td.classList.add("mouse_hand")
        if (col.field === "index_init"){ //COLUMN index_init
            td.appendChild(format_value(index_init, false, false, false, true, col.foldable));
        }else if (col.field === "name"){ //COLUMN NAME
            let attribute = ['pre', pt_code+'\u0020']
            td.appendChild(format_value(val, false, false, attribute, true, col.foldable));
            td,comment_tooltip=generate_comment_tooltip(pt.comment,td,false);
        }else if (col.field === "x_comp"){ //COLUMN X COMPENSATED
            let attribute = ['post','\u0020'+ 'm'];
            if (!pt_code[0].replace(/\s/g, '').length){ //Test if pt_code === " "
                style = "grey";
            }
            td.appendChild(format_value(coord[0], false, nb_decimals, attribute, true, col.foldable, style));
        }else if (col.field === "y_comp"){ //COLUMN Y COMPENSATED
            let attribute = ['post','\u0020'+ 'm'];
            if (!pt_code[1].replace(/\s/g, '').length){ //Test if pt_code === " "
                style = "grey";
            }
            td.appendChild(format_value(coord[1], false, nb_decimals, attribute, true, col.foldable, style));
        }else if (col.field === "z_comp"){ //COLUMN Z COMPENSATED
            let attribute = ['post','\u0020'+ 'm'];
            if (!pt_code[2].replace(/\s/g, '').length){ //Test if pt_code === " "
                style = "grey";
            }
            td.appendChild(format_value(coord[2], false, nb_decimals, attribute, true, col.foldable, style));
        }else if (col.field === "x_shift"){ //COLUMN X SHIFT
            let attribute = ['post','\u0020'+ 'm'];
            if (pt_code[0].replace(/\s/g, '').length){ //Test if pt_code === " "
                shift = pt.shift_from_read[0];
            }
            td.appendChild(format_value(shift, false, nb_decimals, attribute, true, col.foldable));
        }else if (col.field === "y_shift"){ //COLUMN Y SHIFT
            let attribute = ['post','\u0020'+ 'm'];
            if (pt_code[1].replace(/\s/g, '').length){ //Test if pt_code === " "
                shift = pt.shift_from_read[1];
            }
            td.appendChild(format_value(shift, false, nb_decimals, attribute, true, col.foldable));
        }else if (col.field === "z_shift"){ //COLUMN Z SHIFT
            let attribute = ['post','\u0020'+ 'm'];
            if (pt_code[2].replace(/\s/g, '').length){ //Test if pt_code === " "
                shift = pt.shift_from_read[2];
            }
            td.appendChild(format_value(shift, false, nb_decimals, attribute, true, col.foldable));


        }else if (col.field === "x_init"){ //COLUMN X INIT
          let attribute = ['post','\u0020'+ 'm']
          td.appendChild(format_value(pt.coord_read[0], false, nb_decimals, attribute, true, col.foldable));
        }else if (col.field === "y_init"){ //COLUMN Y INIT
            let attribute = ['post','\u0020'+ 'm']
            td.appendChild(format_value(pt.coord_read[1], false, nb_decimals, attribute, true, col.foldable));
        }else if (col.field === "z_init"){ //COLUMN Z INIT
            let attribute = ['post','\u0020'+ 'm']
            td.appendChild(format_value(pt.coord_read[2], false, nb_decimals, attribute, true, col.foldable));
        }else if (col.field === "sigma_x_init"){ //COLUMN SIGMA X INIT
            let attribute = ['post','\u0020'+ 'm'];
            if (pt_code[0] === "x"){
                sigma = pt.sigmas_init[0];
            }
            td.appendChild(format_value(sigma, false, nb_decimals, attribute, true, col.foldable));
        }else if (col.field === "sigma_y_init"){ //COLUMN  SIGMA Y INIT
            let attribute = ['post','\u0020'+ 'm'];
            if (pt_code[1] === "y"){
                sigma = pt.sigmas_init[1];
            }
            td.appendChild(format_value(sigma, false, nb_decimals, attribute, true, col.foldable));
        }else if (col.field === "sigma_z_init"){ //COLUMN SIGMA Z INIT
            let attribute = ['post','\u0020'+ 'm'];
            if (pt_code[2] === "z"){
                sigma = pt.sigmas_init[2];
            }
            td.appendChild(format_value(sigma, false, nb_decimals, attribute, true, col.foldable));
        }else if (col.field === "dev_eta"){ //COLUMN ETA DEFLECTION
            let attribute = ['post','\u0020'+ '"']
            td.appendChild(format_value(pt.dev_eta*(3600*180)/Math.PI, false, 2, attribute, true, col.foldable));
        }else if (col.field === "dev_xi"){ //COLUMN XI DEFLECTION
            let attribute = ['post','\u0020'+ '"']
            td.appendChild(format_value(pt.dev_xi*(3600*180)/Math.PI, false, 2, attribute, true, col.foldable));
        }else if (col.field === "active_obs"){ //COLUMN ACITVE OBS
            td.appendChild(format_value(pt.nbr_active_obs, false, false, false, true, col.foldable));
        }else if (col.field === "sigmax"){ //COLUMN SIGMA X COMP
          let ix="-";
          if (pt.params){
            ix = pt.params[pt.name+"_x"]?parseFloat(pt.params[pt.name+"_x"].sigma) * 1000:"-";
          }
          td.appendChild(format_value(ix, false, nb_decimals_mini, false, true, col.foldable));
        }else if (col.field === "sigmay"){ //COLUMN SIGMA Y COMP
          let iy="-";
          if (pt.params){
            iy = pt.params[pt.name+"_y"]?parseFloat(pt.params[pt.name+"_y"].sigma) * 1000:"-";
          }
          td.appendChild(format_value(iy, false, nb_decimals_mini, false, true, col.foldable));
        }else if (col.field === "sigmaz"){ //COLUMN SIGMA Z COMP
          let iz="-";
          if (pt.params){
            iz = pt.params[pt.name+"_z"]?parseFloat(pt.params[pt.name+"_z"].sigma) * 1000:"-";
          }
          td.appendChild(format_value(iz, false, nb_decimals_mini, false, true, col.foldable));
        }else if (col.field === "emqx"){ //COLUMN EMQ X
          let ix="-";
          if (pt.params){
            ix = pt.params[pt.name+"_x"]?parseFloat(pt.MC_shift_sq_average[0]) * 1000:"-";
          }
          td.appendChild(format_value(ix, false, nb_decimals_mini, false, true, col.foldable));
        }else if (col.field === "emqy"){ //COLUMN EMQ Y
          let iy="-";
          if (pt.params){
            iy = pt.params[pt.name+"_y"]?parseFloat(pt.MC_shift_sq_average[1]) * 1000:"-";
          }
          td.appendChild(format_value(iy, false, nb_decimals_mini, false, true, col.foldable));
        }else if (col.field === "emqz"){ //COLUMN EMQ Z
          let iz="-";
          if (pt.params){
            iz = pt.params[pt.name+"_z"]?parseFloat(pt.MC_shift_sq_average[2]) * 1000:"-";
          }
          td.appendChild(format_value(iz, false, nb_decimals_mini, false, true, col.foldable));
        }else if (col.field === "maxx"){ //COLUMN MAX X
          let ix="-";
          if (pt.params){
            ix = pt.params[pt.name+"_x"]?parseFloat(pt.MC_shift_max[0]) * 1000:"-";
          }
          td.appendChild(format_value(ix, false, nb_decimals_mini, false, true, col.foldable));
        }else if (col.field === "maxy"){ //COLUMN MAX Y
          let iy="-";
          if (pt.params){
            iy = pt.params[pt.name+"_y"]?parseFloat(pt.MC_shift_max[1]) * 1000:"-";
          }
          td.appendChild(format_value(iy, false, nb_decimals_mini, false, true, col.foldable));
        }else if (col.field === "maxz"){ //COLUMN MAX Z
          let iz="-";
          if (pt.params){
            iz = pt.params[pt.name+"_z"]?parseFloat(pt.MC_shift_max[2]) * 1000:"-";
          }
          td.appendChild(format_value(iz, false, nb_decimals_mini, false, true, col.foldable));
        }
        if (comment_tooltip){
            // Tooltip td
            let sp_tooltip = document.createElement("span");
            sp_tooltip.classList.add("tooltip");

            let tooltiptext = document.createElement("span");
            tooltiptext.classList.add("tooltiptext");
            tooltiptext.appendChild(comment_tooltip);

            //Tooltip info click to fold
            if (col.foldable){
                let click_tooltip = document.createElement("span");
                click_tooltip.classList.add("tooltip_fold");
                click_tooltip.innerHTML = "<br>"+_("Click to fold/unfold");
                tooltiptext.appendChild(click_tooltip);
            }

            sp_tooltip.appendChild(tooltiptext);
            td.appendChild(sp_tooltip);
        }
        new_tr.appendChild(td);
    });
    return new_tr;
}

function add_obs_row(columns, obs,j,matrix_inverted){
    let new_tr = document.createElement("tr");

    if (!obs.active)
        new_tr.classList.add('inactive');
    if (obs.variance_from_matrix)
        new_tr.classList.add('variance_punk');

    new_tr.id = `${all_files[obs.file_id]}:${obs.line}`;

    columns.forEach((col, index, array) => {
        let td = document.createElement("td");
        let val=undefined;
        if (!(obs[col.field]==="?")){
            val = obs[col.field];
        }
        let comment_tooltip;

        if(col.foldable)
            td.classList.add("mouse_hand")
        // For each fieldname format value/add post-pre value

        if (col.field === "index_init"){ //COLUMN index_init
            td.appendChild(format_value(j, false, false, false, obs.active, col.foldable))
        }else if (col.field === "href_obs"){ //COLUMN GO TO
            td.innerHTML = '<a href="#' + all_files[all_active_obs[j].file_id] + ':' + all_active_obs[j].line + '">↑</a>';
        }else if (col.field === "active"){ //COLUMN ACTIVE
            let checkbox = document.createElement("INPUT");
            checkbox.setAttribute("type","checkbox")
            checkbox.title=obs.active;
            checkbox.checked = obs.active;
            checkbox.setAttribute("disabled","disabled")
            td.appendChild(checkbox)
        }else if (col.field === "code"){ //COLUMN CODE
            td.innerHTML = codes_obs[obs.code];
            if ((obs.code === 7)||(obs.code === 5)) td.innerHTML += " tr "+obs.num;
            td.setAttribute("field", col.field);
            td,comment_tooltip=generate_comment_tooltip(obs.comment,td);
        }else if (col.field === "from"){ //COLUMN FROM
            let code_from=get_code_pt(obs.from)
            let attribute = ['pre', pt_code_name2html(code_from)+'\u0020']
            td.appendChild(format_value(val, false, false, attribute, obs.active, col.foldable))
            td.setAttribute("field", col.field);
            if (all_pts_name[obs.from]){//To exclude CI obs
              td,comment_tooltip=generate_comment_tooltip(all_pts_name[obs.from].comment,td);
            }
        }else if (col.field === "to"){ //COLUMN TO
            let code_to=get_code_pt(obs.to)
            let attribute = ['pre', pt_code_name2html(code_to)+'\u0020']
            td.appendChild(format_value(val, false, false, attribute, obs.active, col.foldable))
            td.setAttribute("field", col.field);
            if (all_pts_name[obs.from]){//To exclude CI obs
              td,comment_tooltip=generate_comment_tooltip(all_pts_name[obs.to].comment,td);
            }
        }else if (col.field === "original_value"){ //COLUMN ORIGINAL_VALUE
            let attribute = ['post','\u0020'+obs.unit_str]
            td.appendChild(format_value(val, false, nb_decimals, attribute, obs.active, col.foldable))
        }else if (col.field === "obs_length"){ //COLUMN OBS_LENGTH
            let attribute = ['post','\u0020'+'m']
            td.appendChild(format_value(val, false, nb_decimals, attribute, obs.active, col.foldable))

        }else if (col.field === "sigma_total"){ //COLUMN  SIGMA_TOTAL
            let attribute = ['post','\u0020'+obs.unit_str]
            td.appendChild(format_value(val, false, nb_decimals, attribute, obs.active, col.foldable))
            td.setAttribute("field", col.field);
            if (obs.variance_from_matrix)
                td,comment_tooltip = generate_comment_tooltip("Sigma from cov input",td);

        }else if (col.field === "normalized_residual"){ //COLUMN  NORMALIZED_RESIDUAL
            let attribute = ['post','\u0020'+'\u03C3']
            td.appendChild(format_value(val, false, nb_decimals_mini, attribute, obs.active, col.foldable))
            if (!matrix_inverted){
                let val_abs = Math.abs(parseFloat(val));
                if (val_abs > first_step_normalized_residual && val_abs < second_step_normalized_residual)
                    new_tr.classList.add("high")
                else if (val_abs >= second_step_normalized_residual)
                    new_tr.classList.add("veryhigh")
            }
        }else if (col.field === "residual"){ //COLUMN  RESIDUAL
            let attribute = ['post','\u0020'+obs.unit_str]
            td.appendChild(format_value(val, false, nb_decimals, attribute, obs.active, col.foldable))

        }else if (col.field === "residual_mm"){ //COLUMN  RESIDUAL_MM
            let residual_mm = (obs.unit_str === 'm')?parseFloat(obs.residual) * 1000:parseFloat(obs.residual) * obs.obs_length * obs.unit_factor * 1000;
            let attribute = ['post','\u0020'+'mm']
            td.appendChild(format_value(residual_mm, false, nb_decimals_mini, attribute, obs.active, col.foldable))

        }else if (col.field === "sigma_a_posteriori"){ //COLUMN  SIGMA_A_POSTERIORI
            let attribute = ['post', '\u0020'+obs.unit_str]
            td.appendChild(format_value(val, false, nb_decimals, attribute, obs.active, col.foldable))

        }else if (col.field === "residual_std"){ //COLUMN  RESIDUALSTD
            let attribute = ['post','\u0020'+'\u03C3']
            td.appendChild(format_value(val, false, nb_decimals_mini, attribute, obs.active, col.foldable))

        }else if (col.field === "standardized_residual"){ //COLUMN  STANDARDIZED_RESIDUAL
            let attribute = ['post','\u0020'+'\u03C3']
            td.appendChild(format_value(val, false, nb_decimals_mini, attribute, obs.active, col.foldable))
            if (matrix_inverted){
                let val_abs = Math.abs(parseFloat(val));
                if (val_abs > first_step_standardized_residual && val_abs < second_step_standardized_residual)
                    new_tr.classList.add("high")
                else if (val_abs >= second_step_standardized_residual)
                    new_tr.classList.add("veryhigh")
            }
        }else if (col.field === "obs_redondancy"){ //COLUMN  obs_redondancy
            let attribute = ['post','\u0020'+'%']
            td.appendChild(format_value(val, true, 0, attribute, obs.active, col.foldable))

        }else if (col.field === "nabla"){ //COLUMN  NABLA -> paramètre de décentralité 4,1 pour w_max=2,5 et Beta=5%
            let attribute = ['post','\u0020'+obs.unit_str]
            td.appendChild(format_value(val, false, nb_decimals, attribute, obs.active, col.foldable))

        }else if (col.field === "probable_error"){ //COLUMN  PROBABLEERROR
            let attribute = ['post','\u0020'+obs.unit_str]
            td.appendChild(format_value(val, false, nb_decimals, attribute, obs.active, col.foldable))

        }else{
            if (col.fixed_dec)
                td.appendChild(format_value(val, false, nb_decimals, false, obs.active, col.foldable))
            else
                td.appendChild(format_value(val, false, false, false, obs.active, col.foldable))
        }

        //If column is foldable
        if (col.foldable){
            let span_fold = document.createElement("span");
            span_fold.classList.add("foldable");
            span_fold.classList.add("folded");
            span_fold.classList.add("small_unicode");

            span_fold.innerHTML = fill_fold;
            td.appendChild(span_fold);
            td.addEventListener("click", toggle_fold_column);
        }

        // Tooltip td
        let sp_tooltip = document.createElement("span");
        sp_tooltip.classList.add("tooltip");

        let tooltiptext = document.createElement("span");
        tooltiptext.classList.add("tooltiptext");

        //Tooltip file name and row number
        let file_tooltip = document.createElement("span");
        file_tooltip.classList.add("file");
        file_tooltip.innerHTML = `${all_files[obs.file_id]}:${obs.line}`;

        tooltiptext.appendChild(file_tooltip);
        if (comment_tooltip)
            tooltiptext.appendChild(comment_tooltip);

        //Tooltip info click to fold
        if (col.foldable){
            let click_tooltip = document.createElement("span");
            click_tooltip.classList.add("tooltip_fold");
            click_tooltip.innerHTML = "<br>"+_("Click to fold/unfold");
            tooltiptext.appendChild(click_tooltip);
        }

        sp_tooltip.appendChild(tooltiptext);
        td.appendChild(sp_tooltip);

        new_tr.appendChild(td);
    });
  return new_tr;
}

//------------------------------------------------------------------------------
// Functions used in the different parts
//------------------------------------------------------------------------------

function pt_code_name2html(str){//replace space by insecable space in code name
  if (str){
    return String(str).substring(1,4).replace(/ /g,"\u00A0");
  }else{
    return undefined;
  }
}

function generate_comment_tooltip(comment,td,br=true){//use for user comment in different tables
  let comment_tooltip;
  if (!(comment === "")||(comment === "*")){
    //if(comment === "Sigma from cov input"){
    //  td.setAttribute('post', '\u0020\u24B8');
    //}else{
    td.setAttribute('post', '\u0020\u24BE');
    //}
    comment_tooltip = document.createElement("span");
    comment_tooltip.classList.add("comment")
    if (br){//for obs comment
      comment_tooltip.innerHTML = '<br>'+comment;
    }else{//for ellipse and coordinates comment
      comment_tooltip.innerHTML = comment;
    }
  }
  return td,comment_tooltip;
}

function notify(str){
    let div_notify = document.getElementById("notify");

    while (div_notify.firstChild){
        div_notify.removeChild(div_notify.firstChild)
    }

    div_notify.classList.toggle("show_notif");
    let span =  document.createElement("span");
    span.innerHTML = str;
    div_notify.appendChild(span);

    setTimeout(function(){
        div_notify.classList.toggle("show_notif");
        div_notify.removeChild(span);

    },5000);
}

function add_tooltip(str){
        let sp_tooltip = document.createElement("span");
        sp_tooltip.classList.add("tooltip");

        //Tooltip column name
        let sp_tooltiptext = document.createElement("span");
        sp_tooltiptext.classList.add("tooltiptext");
        sp_tooltiptext.innerHTML = str;

        sp_tooltip.appendChild(sp_tooltiptext)

        return sp_tooltip
}

function bool(result){
    if (result) return _("Yes");
    else return _("No");
}

function add_button(report_div,part,div_content,div_display,button_action){//add button for info_calc and suggestions per file
  const p=document.createElement("p");
  const button=document.createElement("input");
  button.type='button';
  button.id=part+'_button';
  button.setAttribute('onclick',button_action);
  p.appendChild(button);

  const div=document.createElement("div");
  div.id=part+'_data';
  if (div.id==="suggestions_data"){//to well display ul html element
    div.appendChild(div_content);
  }else{
    div.innerHTML=div_content;
  }
  div.style.display=div_display;
  p.appendChild(div);

  report_div.appendChild(p);
  return report_div;
}

function toggleButtons(id_content,id_button,show_message,hide_message){//buttons click action
  if (document.getElementById(id_content).style.display === "block"){
    document.getElementById(id_content).style.display = 'none';
    document.getElementById(id_button).style.fontWeight = 'normal';
    document.getElementById(id_button).value = show_message;
  }else{
    document.getElementById(id_content).style.display = 'block';
    document.getElementById(id_button).style.fontWeight = 'bold';
    document.getElementById(id_button).value = hide_message;
  }
}

function pointSortFunction(p1, p2){//make points and obs lists
  if (p1.number > p2.number)
    return 1
  else if (p1.number < p2.number)
    return -1
  else return 0;
}

function obsSortFunction(o1, o2){
  if (o1.number > o2.number)
    return 1
  else if (o1.number < o2.number)
    return -1
  else return 0;
}

function residualSortFunction(o1, o2){
  if (data["computation"]["inverted_matrix"]){//standardized_residual has been computed
    if ((o1.standardized_residual)&&(o2.standardized_residual)){//standardized_residual of the 2 obs exist
      if (Math.abs(o1.standardized_residual) < Math.abs(o2.standardized_residual))
        return 1
      else if (Math.abs(o1.standardized_residual) > Math.abs(o2.standardized_residual))
        return -1
    }else if (o1.standardized_residual){//o1 standardized_residual exist but not o2
      return -1
    }else if (o2.standardized_residual){//o2 standardized_residual exist but not o1
      return 1
    }else{//o1 and o2 standardized_residual not exist
      return 0;
    }
  }else{
    if (Math.abs(o1.normalized_residual) < Math.abs(o2.normalized_residual))
      return 1
    else if (Math.abs(o1.normalized_residual) > Math.abs(o2.normalized_residual))
      return -1
    else return 0;
  }
}

function residual_is_big(obs){
  if (data["computation"]["inverted_matrix"] && (Math.abs(obs.standardized_residual)>first_step_standardized_residual))
    return true;
  else if (!data["computation"]["inverted_matrix"] && (Math.abs(obs.normalized_residual)>first_step_normalized_residual))
    return true;
  else
    return false;
}

function get_data_suggestions(instrum,type,red_type_instrum,nb_red_type_instrum,num_type_instrum,sum_sigma_type_instrum,red_tot,mu){
  let warning="";
  const master_span=document.createElement("span");
  master_span.classList.add("tooltipp");
  master_span.setAttribute('post', '\u00A0\u0020\u24D8');

  const not_enough=_("Not enough observations");
  const not_enough_red=_("Not enough redundancy");
  let sugg_type_instrum=0;
  let sigma_type_instrum=0;
  const av_red=red_type_instrum[type][instrum]/num_type_instrum[type][instrum]*100;
  if (num_type_instrum[type][instrum]<10){
    sugg_type_instrum=not_enough;
  }else if (av_red<30){
    warning="&#9888; "+_("The partial redundancies average of this type is less than 30%");
    master_span.setAttribute('warn_post', '\u00A0\u0020\u26A0');
    master_span.setAttribute('post', '');
    sugg_type_instrum=not_enough_red;
  }else{
    sigma_type_instrum=sum_sigma_type_instrum[type][instrum]/red_type_instrum[type][instrum];
    sugg_type_instrum= to_fixed(parseFloat((sigma_type_instrum/mu)*(red_tot)), nb_decimals);
  }
  const li = document.createElement('li');
  li.innerHTML=_(full_name_type[type]) + _(": ") + sugg_type_instrum;

  const span1=document.createElement("span");
  span1.classList.add("tooltipptext");
  span1.innerHTML=_("Observation number of this type: ") + num_type_instrum[type][instrum] + _(" including ") + nb_red_type_instrum[type][instrum] + _(" redundant ");

  const span2=document.createElement("span");
  span2.classList.add("sum_red");
  span2.innerHTML='</br>'+_("Sum of partial redundancies of this type: ")+to_fixed(red_type_instrum[type][instrum], 0)+" "+_("which correponds to")+" "+to_fixed((red_type_instrum[type][instrum]/red_tot*100), 0)+" % "+_("of the total redundancy");

  const span3=document.createElement("span");
  span3.classList.add("av_red");
  span3.innerHTML='</br>'+_("Partial redundancies average of this type: ")+to_fixed(av_red, 0)+' %';

  const span4=document.createElement("span");
  span4.classList.add("warn_red");
  span4.innerHTML='</br>'+warning;

  master_span.appendChild(span1);
  span1.appendChild(span2);
  span2.appendChild(span3);
  span3.appendChild(span4);

  li.appendChild(master_span);

  return li;
}

function get_code_pt(pt_obs){
    if (pt_obs==="?"){
        return undefined;
    }else{
        return all_pts_name[pt_obs].code_name;
    }
}

function toggle(column){
  let name_cookie="style_" + column;
  let mask_column='mask_' + column;
  let new_style="";
  if (getCookie(name_cookie)){
    if (getCookie(name_cookie)==="table-cell"){
      new_style="none";
      document.getElementById(column).hide();
      document.getElementById(mask_column).show();
    }else{
      new_style="table-cell";
      document.getElementById(column).show();
      document.getElementById(mask_column).hide();
    }
  }else{
    new_style="none";
    document.getElementById(column).hide();
    document.getElementById(mask_column).show();
  }
  setCookie(name_cookie,new_style);
}

function setCookie(cname, cvalue){
  document.cookie = cname + "=" + cvalue;
}

function getCookie(cname){
  let name = cname + "=";
  let decodedCookie = decodeURIComponent(document.cookie);
  let ca = decodedCookie.split(';');
  for (let i = 0; i <ca.length; i++) {
    let c = ca[i];
    while (c.charAt(0) === ' ') {
      c = c.substring(1);
    }
    if (c.indexOf(name) === 0) {
      return c.substring(name.length, c.length);
    }
  }
  return "";
}

function get_component(){
  let component=[];
  if (data["config"]["use_proj"]){
    component=["E","N"];
  }else{
    component=["x","y"];
  }
  if (data["config"]["use_ellips_height"])
    component.push(_("Eh"));
  else
    component.push(_("Gh"));
  return component;
}

function add_section_to_TOC(anchor, section_title, section_title_mini){
    let p = document.createElement("p");
    let a_toc = document.createElement("a");
    a_toc.setAttribute("href", anchor);
    a_toc.textContent = section_title;

    p.appendChild(a_toc);
    let toc = document.getElementById("table_of_content");
    toc.appendChild(p);

    //for mini toc
    p = document.createElement("p");
    a_toc = document.createElement("a");
    a_toc.setAttribute("href", anchor);
    a_toc.textContent = section_title_mini;
    p.appendChild(a_toc);
    toc = document.getElementById("table_of_content_mini");
    toc.appendChild(p);
}

function add_back_to_top_button(section){//add arrow buttton to back in top
  let a_top = document.createElement("a");
  a_top.href = "#top";
  a_top.innerHTML = ('&#8593;');
  a_top.title=_("Back to top");
  section.appendChild(a_top);
}

function create_title_section(id,section_title,section_title_mini){
  add_section_to_TOC("#"+id, section_title, section_title_mini)
  let section = document.createElement("h2");
  section.id = id;
  section.innerHTML = section_title;
  add_back_to_top_button(section);
  let report_div = document.getElementById("report");
  report_div.appendChild(section);
  return report_div;
}

//------------------------------------------------------------------------------
// Display functions of parts and entry associated in summary
//------------------------------------------------------------------------------
function show_version(){
  add_section_to_TOC("#top","Comp3D","C3D")
  let report_div = document.getElementById("report");

  let version = document.createElement("p");
  version.innerHTML = _("Version: ") + data["COMP3D_VERSION"];
  version.id = 'version'
  report_div.appendChild(version);

  let commit = document.createElement("p");
  commit.innerHTML = _("Commit: ") + data["COMP3D_COMMIT"];
  commit.id = 'commit';
  report_div.appendChild(commit);

  /*let options = document.createElement("p");
  options.innerHTML = _("Options: ") + data["COMP3D_OPTIONS"];
  options.id = 'options'
  report_div.appendChild(options);*/

  let license = document.createElement("p");
  license.innerHTML = data["COMP3D_COPYRIGHT"]+ ' - ' + data["COMP3D_LICENSE"];
  license.id = 'license';
  report_div.appendChild(license);

  let link = document.createElement("a");
  link.href = src_link;
  link.innerHTML = src_link;
  report_div.appendChild(link);
}

//------------------------------------------------------------------------------
//--------------- Config information
//------------------------------------------------------------------------------
function show_info_work(){
  const report_div = create_title_section('info_work',_('Project configuration'),_('Conf'));

  let config = document.createElement("dl");
  config.classList.add('inline-flex');

  if (data["config"]["name"]===""){
    config=add_dl_row(config,_("Name"),"-");
  }else{
    config=add_dl_row(config,_("Name"),data["config"]["name"]);
  }
  if (data["config"]["description"]===""){
    config=add_dl_row(config,_("Description"),"-");
  }else{
    config=add_dl_row(config,_("Description"),data["config"]["description"]);
  }
  config=add_dl_row(config,_("Root COR file"),data["config"]["root_COR_file"]);
  config=add_dl_row(config,_("Root OBS file"),data["config"]["root_OBS_file"]);
  if (data["config"]["coord_cov_file"]) {
    config=add_dl_row(config,_("Coord var/covar file"),data["config"]["coord_cov_file"]);
  }
  const units = {
    "0": _("Rad"),
    "1": _("Grad"),
    "2": _("Deg"),
    "3": _("DMS")
  };
  config=add_dl_row(config,_("Unit"),units[data["config"]["files_unit"]]);
  config=add_dl_row(config,_("Decimal places number"),data["config"]["nb_digits"],_("clue for the precision given in the report, some value are given with less or more decimal places"));
  const compute_nature = {
    "0": _("Compensation"),
    "1": _("Propagation Simulation"),
    "2": _("Monte-Carlo Simulation")
  };
  config=add_dl_row(config,_("Computation nature"),compute_nature[data["config"]["compute_type"]]);
  if (data["config"]["compute_type"] === 0){
    config=add_dl_row(config,_("Normal matrix inversion"),bool(data["config"]["invert_matrix"]),_("Required to get confidence intervals and ellipsoids and get redondancy informations"));
  }
  if (data["config"]["compute_type"] !== 2){//No Monte Carlo
    config=add_dl_row(config,_("Internal constraints"),bool(data["config"]["internal_constraints"]));
  }
  config=add_dl_row(config,_("Refraction coefficient"),to_fixed(parseFloat(data["config"]["refraction"]), nb_decimals),_("Only impacts vertical angle measures"));
  config=add_dl_row(config,_("Georeferencing"),bool(data["config"]["use_proj"]));
  if (data["config"]["use_proj"]){
    config=add_dl_row(config,_("Projection definition"),data["config"]["proj_def"]);
    config=add_dl_row(config,_("Projection center"),"E=" + parseInt(data["config"]["local_center"][0]) + " " +
                                                    "N=" + parseInt(data["config"]["local_center"][1]));
  }else{
    config=add_dl_row(config,_("Center latitude"),to_fixed(parseFloat(data["config"]["center_latitude"]), 2),_("Latitude to determine the local curvature of the ellipsoid"));
    config=add_dl_row(config,_("Local coordinates center"),"X=" + parseInt(data["config"]["local_center"][0]) + " " +
                                                           "Y=" + parseInt(data["config"]["local_center"][1]));
  }
  config=add_dl_row(config,_("Convergence criterion"),to_fixed(parseFloat(data["config"]["convergence_criterion"]), 6),_("\u03C30 difference between 2 iterations"));
  config=add_dl_row(config,_("Maximum iterations"),data["config"]["max_iterations"]);
  config=add_dl_row(config,_("Ellipsoidal heights"),bool(data["config"]["use_ellips_height"]));
  config=add_dl_row(config,_("Additional iterations"),data["config"]["force_iterations"],_("Additional iteration number after convergence"));

  report_div.appendChild(config);
}

//------------------------------------------------------------------------------
//--------------- Map function
//------------------------------------------------------------------------------
function createMap(){
  const report_div = document.getElementById("report");
  const map=document.createElement("div");
  map.id="mapid";
  report_div.appendChild(map);

  const markerIconF = L.icon({
    iconUrl: 'res/marker_f.png',
    iconSize:     [16, 16], // size of the icon
    iconAnchor:   [8, 8], // point of the icon which will correspond to marker's location
    //popupAnchor:  [-3, -76] // point from which the popup should open relative to the iconAnchor
  });
  const markerIconS = L.icon({
    iconUrl: 'res/marker_s.png',
    iconSize:     [16, 16], // size of the icon
    iconAnchor:   [8, 8], // point of the icon which will correspond to marker's location
    //popupAnchor:  [-3, -76] // point from which the popup should open relative to the iconAnchor
  });
  const markerIconT = L.icon({
    iconUrl: 'res/marker_t.png',
    iconSize:     [16, 16], // size of the icon
    iconAnchor:   [8, 8], // point of the icon which will correspond to marker's location
    //popupAnchor:  [-3, -76] // point from which the popup should open relative to the iconAnchor
  });
  const markerIconR1 = L.icon({
    iconUrl: 'res/marker_r1.png',
    iconSize:     [32, 32], // size of the icon
    iconAnchor:   [16, 16], // point of the icon which will correspond to marker's location
    //popupAnchor:  [-3, -76] // point from which the popup should open relative to the iconAnchor
  });
  const markerIconR2 = L.icon({
    iconUrl: 'res/marker_r2.png',
    iconSize:     [32, 32], // size of the icon
    iconAnchor:   [16, 16], // point of the icon which will correspond to marker's location
    //popupAnchor:  [-3, -76] // point from which the popup should open relative to the iconAnchor
  });

  let all_latlong = [];
  let key="coord_compensated_cartesian";

  if (data["computation"]["projection"]["is_georef"]){
      mymap = L.map('mapid');
      key="coord_compensated_latlong"
      if (!data["computation"]["compensation_done"])
        key="coord_init_latlong";
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            maxZoom: 35,
            attribution: '&copy; <a href="https://openstreetmap.org/copyright">OpenStreetMap contributors</a>',
            opacity: 0.6
          }).addTo(mymap);
  }else{
      mymap = L.map('mapid',{crs: L.CRS.Simple, minZoom: -10});
  }
  mymap.scrollWheelZoom.disable();
  mymap.on('focus', function() { mymap.scrollWheelZoom.enable(); });
  mymap.on('blur', function() { mymap.scrollWheelZoom.disable(); });

  let info = L.control();
  info.onAdd = function (map) {
      this._div = L.DomUtil.create('div', 'map-info');
      this._div.innerHTML = '<p><img src="res/marker_f.png"/>'
        +_("Ref")+'</p><p><img src="res/marker_s.png"/>'
        +_("Station")+'</p><p><img src="res/marker_t.png"/>'
        +_("Target")+'</p>';
      return this._div;
  };
  info.addTo(mymap);

  let len_factorE=1;
  let len_factorN=1;
  let isSimpleCRS=true;
  if ((data["computation"]["projection"]["is_georef"]) && (all_pts.length>0)){
    isSimpleCRS=false;
    len_factorE=360/(Math.PI*2*parseFloat(data.computation.projection.earth_model_radius))/Math.cos(Math.PI/180*all_pts[0][key][1]);
    len_factorN=360/(Math.PI*2*parseFloat(data.computation.projection.earth_model_radius));
  }
  for (let i = 0; i < all_axes.length; i++) {
    let axe = all_axes[i];
    let pos = all_axes[i].origin[key];
    const key_a = Object.keys(axe.params).find(key => key.match(axe.name+'_Aa.*'));
    const key_b = Object.keys(axe.params).find(key => key.match(axe.name+'_Ab.*'));
    const key_c = Object.keys(axe.params).find(key => key.match(axe.name+'_Ac.*'));

    const axe_norm=Math.sqrt(
                           axe.params[key_a].value*axe.params[key_a].value
                           +axe.params[key_b].value*axe.params[key_b].value
                           +axe.params[key_c].value*axe.params[key_c].value);
    let ellips_az = Math.atan2(axe.params[key_a].value,axe.params[key_b].value)*180/Math.PI;
    let axe_proj_norm = Math.sqrt(axe.params[key_a].value*axe.params[key_a].value
                                  +axe.params[key_b].value*axe.params[key_b].value);

    for (let j = 0; j< axe.targets.length; j++) {
        let target = axe.targets[j];
        const key_l = Object.keys(axe.params).find(key => key.match(axe.name+'_st.*_T'+target.num+'_l'));
        const key_r = Object.keys(axe.params).find(key => key.match(axe.name+'_st.*_T'+target.num+'_r'));
        if (axe.params[key_l].value == null || axe.params[key_r].value == null) continue;

        let ellips_ctr = [
                          pos[0]+axe.params[key_l].value*axe.params[key_a].value*len_factorE,
                          pos[1]+axe.params[key_l].value*axe.params[key_b].value*len_factorN
                         ];
        let ellips_a = axe.params[key_r].value;
        //var ellips_b = ellips_a*axe_proj_norm/axe_norm;
        let ellips_b = Math.abs(ellips_a*axe.params[key_c].value/axe_norm);
        L.ellipse([ellips_ctr[1],ellips_ctr[0]],[ellips_a,ellips_b],
            ellips_az,{color: 'coral',opacity : 0.7,fill:false, simpleCRS:isSimpleCRS}).addTo(mymap);
    }
  }

  for (let i = 0; i < all_axes.length; i++) {
    let axe = all_axes[i];
    const key_a = Object.keys(axe.params).find(key => key.match(axe.name+'_Aa.*'));
    const key_b = Object.keys(axe.params).find(key => key.match(axe.name+'_Ab.*'));
    const key_c = Object.keys(axe.params).find(key => key.match(axe.name+'_Ac.*'));
    let pos = all_axes[i].origin[key];
    const axe_norm=Math.sqrt(axe.params[key_a].value*axe.params[key_a].value
               +axe.params[key_b].value*axe.params[key_b].value
               +axe.params[key_c].value*axe.params[key_c].value);
    if (axe_norm > 0) {
        let axe_len_m=2//show +/- 2m
        let posA = [pos[0]+axe_len_m*len_factorE*axe.params[key_a].value/axe_norm, pos[1]+axe_len_m*len_factorN*axe.params[key_b].value/axe_norm];
        let posB = [pos[0]-axe_len_m*len_factorE*axe.params[key_a].value/axe_norm, pos[1]-axe_len_m*len_factorN*axe.params[key_b].value/axe_norm];
        let polyline = L.polyline([
            [posA[1], posA[0]],
            [posB[1], posB[0]]
          ],{weight: 8, opacity : 1, color: "olivedrab", dashArray:"12"}).addTo(mymap);
    }
  }

  let layerObsLine = [];
  let layerObsDir = [];

  function createObsLine(from, to, obs_color, layerObsLine, layerObsDir) {
    let v = [from[0]-to[0], to[1]-from[1]];
    let norm = Math.sqrt(v[0]*v[0]+v[1]*v[1]);
    layerObsLine.push(L.polyline([
      [from[1], from[0]],
      [to[1], to[0]]
    ],{weight: 1, opacity : 0.5, color: obs_color}));
    if (norm>0.01*len_factorE) {
      v[0] = v[0] / 50;
      v[1] = v[1] / 50;
      layerObsDir.push(L.polyline([
        [(from[1]+to[1])/2+v[1]*2, (from[0]+to[0])/2-v[0]*2],
        [(from[1]+to[1])/2+v[0]+v[1], (from[0]+to[0])/2+v[1]-v[0]]
      ],{weight: 1, opacity : 0.5, color: obs_color}));
      layerObsDir.push(L.polyline([
        [(from[1]+to[1])/2+v[1]*2, (from[0]+to[0])/2-v[0]*2],
        [(from[1]+to[1])/2-v[0]+v[1], (from[0]+to[0])/2-v[1]-v[0]]
      ],{weight: 1, opacity : 0.5, color: obs_color}));
    }
  }

  for (let i = 0; i < all_active_obs.length; i++){
    let obs=all_active_obs[i];
    if (obs.code>0 && obs.code<110) { //do not draw coord, axes and internal contraints
      let coord_latlong_from = all_pts_name[obs.from][key];
      let coord_latlong_to = all_pts_name[obs.to][key];
      let obs_color = "darkmagenta";
      createObsLine(coord_latlong_from, coord_latlong_to, obs_color, layerObsLine, layerObsDir);
    }
  }
  let layerObs={"Obs":L.layerGroup(layerObsLine), "Dir":L.layerGroup(layerObsDir)};
  L.control.layers(null, layerObs, {collapsed:false}).addTo(mymap);

  let kernVectScale = 5*len_factorE;
  let kernVectColor = "#FF0000FF";

  function drawKernVect(v, layer) {
    const pt = all_pts[v.n];
    const pos = pt[key];
    const vx = v.x*kernVectScale;
    const vy = v.y*kernVectScale;
    const vz = v.z*kernVectScale;
    const miniSize2 = 0.1*len_factorE*len_factorE;

    if (vx*vx+vy*vy>miniSize2){
      layer.push(L.polyline([
        [pos[1], pos[0]],
        [pos[1]+vy, pos[0]+vx]
      ],{weight: 2, opacity : 1, color: kernVectColor}));
      layer.push(L.polyline([
        [pos[1]+vy, pos[0]+vx],
        [pos[1]+vy+(-vx-vy)/8, pos[0]+vx+(+vy-vx)/8]
      ],{weight: 2, opacity : 1, color: kernVectColor}));
      layer.push(L.polyline([
        [pos[1]+vy, pos[0]+vx],
        [pos[1]+vy+(+vx-vy)/8, pos[0]+vx+(-vy-vx)/8]
      ],{weight: 2, opacity : 1, color: kernVectColor}));
    }
    if (vz*vz>miniSize2){
      layer.push(L.polyline([
        [pos[1], pos[0]],
        [pos[1]+vz, pos[0]]
      ],{weight: 2, opacity : 1, color: kernVectColor}));
      layer.push(L.polyline([
        [pos[1]+vz*0.4, pos[0]-vz/16],
        [pos[1]+vz*0.6, pos[0]+vz/16]
      ],{weight: 2, opacity : 1, color: kernVectColor}));
      layer.push(L.polyline([
        [pos[1]+vz*0.4, pos[0]-vz/16],
        [pos[1]+vz*0.4, pos[0]+vz/16]
      ],{weight: 2, opacity : 1, color: kernVectColor}));
      layer.push(L.polyline([
        [pos[1]+vz*0.6, pos[0]-vz/16],
        [pos[1]+vz*0.6, pos[0]+vz/16]
      ],{weight: 2, opacity : 1, color: kernVectColor}));
      layer.push(L.polyline([
        [pos[1]+vz, pos[0]],
        [pos[1]+vz-vz/8, pos[0]-vz/8]
      ],{weight: 2, opacity : 1, color: kernVectColor}));
      layer.push(L.polyline([
        [pos[1]+vz, pos[0]],
        [pos[1]+vz-vz/8, pos[0]+vz/8]
      ],{weight: 2, opacity : 1, color: kernVectColor}));
    }
  }

  function drawKernCirc(pos, val, layer) {
    if (val>0)
      layer.push(L.marker([pos[1], pos[0]], {icon:markerIconR1}));
    else
      layer.push(L.marker([pos[1], pos[0]], {icon:markerIconR2}));
  }

  function drawKernel(num, kernLayers) {
    let layer = [];
    let kernData = data["computation"]["kernel"][num];
    let allVects = {}; //{x,y} indexed by pt name
    for (const param in kernData){
      let val = kernData[param].val;
      let dim = param[param.lastIndexOf("_")+1];
      if (dim >= '0' && dim <= '9')
        dim = param.substring(param.lastIndexOf("_", param.lastIndexOf("_")-1)+1); //dim is after the second "_" from the end

      let numpt = kernData[param].num_pt;
      let pt = all_pts[numpt];
      if ((dim[0]==="G")||(dim[0]==="R"))
        drawKernCirc(pt[key], val, layer);
      if (dim[0]==="x"){
        if (pt.name in allVects)
          allVects[pt.name]["x"] = val;
        else{
          allVects[pt.name] = {"n":numpt,"x":0.0,"y":0.0,"z":0.0};
          allVects[pt.name]["x"] = val;
        }
      }else if (dim[0]==="y"){
        if (pt.name in allVects)
          allVects[pt.name]["y"] = val;
        else {
          allVects[pt.name] = {"n":numpt,"x":0.0,"y":0.0,"z":0.0};
          allVects[pt.name]["y"] = val;
        }
      }else if (dim[0]==="z"){
        if (pt.name in allVects)
          allVects[pt.name]["z"] = val;
        else {
          allVects[pt.name] = {"n":numpt,"x":0.0,"y":0.0,"z":0.0};
          allVects[pt.name]["z"] = val;
        }
      }
    }
    for (const pt in allVects)
      drawKernVect(allVects[pt], layer);
    let kernLayer = L.layerGroup(layer);
    if (num===0)
      kernLayer.addTo(mymap);
    kernLayers["Indetermination "+num.toString()] = kernLayer;
  }

  if (data["computation"]["kernel"]){
    let kernLayers = {};
    for (let num=0;num<data["computation"]["kernel"].length;num++)
      drawKernel(num, kernLayers);
    L.control.layers(kernLayers, null, {collapsed:false}).addTo(mymap);
  }

  let all_markers=[];
  let all_markers_names=[];
  for (let i = 0; i < nb_pts; i++){
    let pt = all_pts[i];
    let coord_latlong=all_pts[i][key];
    if ([1,2,3,5,7,9].indexOf(all_pts[i].code)>=0){
      all_markers.push(L.marker([coord_latlong[1], coord_latlong[0]], {icon:markerIconF}).addTo(mymap));
      all_markers_names.push(data.all_point_names[i]);
      continue;
    }
    let iconFound=false;
    for (let k =0;k<(pt.stations.length);k++){
      const st=pt.stations[k];
      if (st.type !== "simple"){
        all_markers.push(L.marker([coord_latlong[1], coord_latlong[0]], {icon:markerIconS}).addTo(mymap));
        all_markers_names.push(data.all_point_names[i]);
        iconFound=true;
        continue;
      }
    }
    if (!iconFound){
      all_markers.push(L.marker([coord_latlong[1], coord_latlong[0]], {icon:markerIconT}).addTo(mymap));
      all_markers_names.push(data.all_point_names[i]);
    }
  }

  //add tooltips on background, 90% faster
  setTimeout(() => {
          for (let i =0; i<all_markers.length;i++){
            all_markers[i].bindTooltip(all_markers_names[i],{permanent: true, direction: 'right', className: 'comp-tooltips'});
          }
        }, 10);

  L.control.scale({imperial:false}).addTo(mymap);
  for (let i = 0; i < nb_pts; i++) {
    let coord_latlong=all_pts[i][key];
    if ((all_pts[i].code<11) && isFinite(coord_latlong[0]) && isFinite(coord_latlong[1]))
      all_latlong.push( [coord_latlong[1],coord_latlong[0]] );
  }
  if (all_latlong.length>0){
    minx=all_latlong[0][0];
    miny=all_latlong[0][1];
    maxx=all_latlong[0][0];
    maxy=all_latlong[0][1];
    for (let j=0;j<all_latlong.length;j++){
      let pt=all_latlong[j];
      if (minx>pt[0]) minx=pt[0];
      if (miny>pt[1]) miny=pt[1];
      if (maxx<pt[0]) maxx=pt[0];
      if (maxy<pt[1]) maxy=pt[1];
    }
    minx-=0.0001;
    miny-=0.0001;
    maxx+=0.0001;
    maxy+=0.0001;
    mymap.fitBounds( [[minx,miny],[maxx,maxy]]);

    L.Control.ResetZoom = L.Control.extend({
        onAdd: function(map) {
            var div = L.DomUtil.create('div');
            div.classList.add("leaflet-control-zoom");
            div.classList.add("leaflet-bar");
            div.classList.add("leaflet-control");
            div.innerHTML='<a class="leaflet-control-zoom-in" title="Reset zoom" onclick="mymap.fitBounds( [[minx,miny],[maxx,maxy]]);">&#128306;</a>';
            return div;
        },
        onRemove: function(map) {}
    });
    L.control.resetZoom = function(opts) {
        return new L.Control.ResetZoom(opts);
    }
    L.control.resetZoom({ position: 'topleft' }).addTo(mymap);
  }
}

//------------------------------------------------------------------------------
//--------------- Calculation information
//------------------------------------------------------------------------------
function show_info_calc(){
  let report_div = create_title_section('info_calc',_('Computation information'),_('Info'));

  let calc = document.createElement("dl");
  calc.classList.add('inline-flex');

  calc=add_dl_row(calc,_("Compensation done"),bool(data["computation"]["compensation_done"]))
  if (data["all_uninitializable_point_names"] && (data["all_uninitializable_point_names"].length>0)){
    calc=add_dl_row(calc,_("Non-initialisable points"),data["all_uninitializable_point_names"].join(" "));
  }
  if (data["config"]["compute_type"] === 0){
    calc=add_dl_row(calc,_("\u03C30 initial"),to_fixed(parseFloat(data["computation"]["sigma_0_init"]), nb_decimals));
    calc=add_dl_row(calc,_("\u03C30 final"),to_fixed(parseFloat(data["computation"]["sigma_0_final"]), nb_decimals));
  }
  calc=add_dl_row(calc,_("Iterations"),data["computation"]["nbr_iterations"]);
  let interrupted_class = "";
  if (data["computation"]["interrupted"]){
    interrupted_class = "warn_red";
  }
  calc=add_dl_row(calc,_("Computation interruption"),bool(data["computation"]["interrupted"]),"",interrupted_class);
  calc=add_dl_row(calc,_("Rank default"),data["computation"]["rank_deficiency"]);
  if (data["computation"]["computation_start"]!=="not-a-date-time"){
    calc=add_dl_row(calc,_("Computation start"),data["computation"]["computation_start"]);
    calc=add_dl_row(calc,_("Computation duration"),data["computation"]["computation_duration"]);
  }
  calc=add_dl_row(calc,_("Sphere radius"),to_fixed(parseFloat(data["computation"]["projection"]["earth_model_radius"]), 2) + ' m');
  calc=add_dl_row(calc,_("Total observations number"),data["computation"]["nbr_all_obs"]);
  calc=add_dl_row(calc,_("Active observations number"),data["computation"]["nbr_active_obs"]);
  calc=add_dl_row(calc,_("Parameters"),data["computation"]["nbr_parameters"]);
  calc=add_dl_row(calc,_("Normal matrix inversion"),bool(data["computation"]["inverted_matrix"]));
  calc=add_dl_row(calc,_("Monte-Carlo simulation done"),bool(data["computation"]["Monte_Carlo_done"]));
  calc=add_dl_row(calc,_("Internal constraints"),bool(data["computation"]["internal_constraints"]));
  calc=add_dl_row(calc,_("Using vertical deflection"),bool(data["computation"]["use_vertical_deflection"]));
  calc=add_dl_row(calc,_("Solver name"),data["computation"]["solver_name"]);
  if (data["computation"]["projection"]["is_georef"]){
    const R=data["computation"]["projection"]["rot_global2geocentric"];
    const T=data["computation"]["projection"]["center_cartgeocentric"];
    if (data["computation"]["projection"]["input_proj_EPSG"]>0){
      calc=add_dl_row(calc,_("Projection name"),"EPSG " + data["computation"]["projection"]["input_proj_EPSG"]+_(": ")+data["computation"]["projection"]["input_proj_name"]);
    }
    calc=add_dl_row(calc,_("User proj def"),data["computation"]["projection"]["input_proj_def"]);
    calc=add_dl_row(calc,_("Stereo def"),data["computation"]["projection"]["stereo_def"]);
    calc=add_dl_row(calc,_("LatLong def"),data["computation"]["projection"]["latlong_def"]);
    calc=add_dl_row(calc,_("Geocent def"),data["computation"]["projection"]["geocent_def"]);
    const table = document.createElement("table");
    table.id = "cart2geoc";
    const table_content="<th class='likedt' colspan='4'>" + _("Cartesian global to Geocentric:") + "</th>"
     + "<tr><td></td><td>" + R[0][0] + "</td><td>" + R[0][1] + "</td><td>" + R[0][2] + "</td><td></td><td>" + T[0] + "</td></tr>"
     + "<tr><td>Geocentr =</td><td>" + R[1][0] + "</td><td>" + R[1][1] + "</td><td>" + R[1][2] + '</td><td>* Global + </td><td>' + T[1] + "</td></tr>"
     + "<tr><td></td><td>" + R[2][0] + "</td><td>" + R[2][1] + "</td><td>" + R[2][2] + "</td><td></td><td>" + T[2] + '</td></tr>';
     table.innerHTML=table_content;
     calc.appendChild(table);
  }

  report_div.appendChild(calc);

  report_div=add_button(report_div,"read_config",data["computation"]["messages_read_config"],'none',
    'toggleButtons("read_config_data","read_config_button",_("Show configuration file reading messages"),_("Hide configuration file reading messages"))');
  toggleButtons("read_config_data","read_config_button",_("Show configuration file reading messages"),_("Hide configuration file reading messages"));

  report_div=add_button(report_div,"read_data",data["computation"]["messages_read_data"],'block',
    'toggleButtons("read_data_data","read_data_button",_("Show file reading messages"),_("Hide file reading messages"))');
  toggleButtons("read_data_data","read_data_button",_("Show file reading messages"),_("Hide file reading messages"));

  report_div=add_button(report_div,"set_least_squares",data["computation"]["messages_set_least_squares"],'block',
    'toggleButtons("set_least_squares_data","set_least_squares_button",_("Show computation configuration messages"),_("Hide computation configuration messages"))');
  toggleButtons("set_least_squares_data","set_least_squares_button",_("Show computation configuration messages"),_("Hide computation configuration messages"));

  report_div=add_button(report_div,"computation",data["computation"]["messages_computation"],'none',
    'toggleButtons("computation_data","computation_button",_("Show computation messages"),_("Hide computation messages"))');
  toggleButtons("computation_data","computation_button",_("Show computation messages"),_("Hide computation messages"));
}

//------------------------------------------------------------------------------
//--------------- Sigma 0 evolution graph
//------------------------------------------------------------------------------
function show_evol_sigma0(){
  const report_div = create_title_section('evol_sigma0',_('\u03C30 evolution'),_('\u03C30'));
  let all_sigma0_labels = [];
  let chi2_max = [];
  let chi2_min = [];
  let all_sigma0_val = [];
  for (let index = 0; index < data["computation"]["all_sigma0"].length; index++) {
    all_sigma0_labels.push(index);
    all_sigma0_val.push(data["computation"]["all_sigma0"][index]);
    chi2_max.push(data["computation"]["chi2_test"]["max"]);
    chi2_min.push(data["computation"]["chi2_test"]["min"]);
  }
  const sigma0_evol_chart_config = {
    type: 'line',
    data: {
      labels: all_sigma0_labels,
      datasets: [{
          label: "\u03C30",
          backgroundColor: "rgba(255,162,0,0.5)",
          fill: false,
          borderColor: "rgba(255,162,0,1)",
          pointColor: "rgba(255,162,0,1)",
          pointStrokeColor: "#fff",
          data: all_sigma0_val,
          lineTension: 0.0
        },
        {
          label: "\u03C7\u00B2 max",
          borderColor: "rgba(150,100,100,0.9)",
          pointRadius: 0,
          data: chi2_max,
          fill: false
        },
        {
          label: "\u03C7\u00B2 min",
          borderColor: "rgba(100,150,100,0.9)",
          pointRadius: 0,
          data: chi2_min,
          fill: false
        }
      ]
    },
    options: {
      responsive: true,
      title: {
        display: false,
      },
      tooltips: {
        mode: 'index',
        intersect: false,
      },
      hover: {
        mode: 'nearest',
        intersect: true
      },
      scales: {
        xAxes: [{
          display: true,
          scaleLabel: {
            display: true,
            labelString: _("Iteration")
          }
        }],
        yAxes: [{
          display: true,
          scaleLabel: {
            display: true,
            labelString: '\u03C30'
          },
          type: 'logarithmic',
          ticks: {
            min: 0,
            callback: function(value, index, values) {
              str = value.toExponential()
              if ((str[0] === "1") || (str[0] === "2") || (str[0] === "5"))
                return value.toString();
              else return "";
            },
          }
        }]
      }
    }
  };

  const div=document.createElement("div");
  div.classList.add("graph");
  const canvas=document.createElement("canvas");
  canvas.id='sigma0_chart';
  div.appendChild(canvas);
  report_div.append(div);
  const ctx=canvas.getContext("2d");
  let myNewChart = new Chart(ctx, sigma0_evol_chart_config);
}

//------------------------------------------------------------------------------
//--------------- Chi2 test
//------------------------------------------------------------------------------
function show_chi2(){
  let report_div = create_title_section("test_chi2",_("\u03C7\u00B2 test"),_("\u03C7\u00B2"));
  const chi2OK = (parseFloat(data["computation"]["chi2_test"]["min"]) < parseFloat(data["computation"]["sigma_0_final"])) &&
                 (parseFloat(data["computation"]["sigma_0_final"]) < parseFloat(data["computation"]["chi2_test"]["max"]));
  let emoticon = "?";
  if (!chi2OK) emoticon = "&#128547;";
  else emoticon = "&#128517;";
  if (parseFloat(data["computation"]["sigma_0_final"]) > 10)
    emoticon = "&#128561;";
  else if (parseFloat(data["computation"]["sigma_0_final"]) > 100)
    emoticon = "&#128552;";
  let confidence_section = document.createElement("p");
  confidence_section.innerHTML = _("Confidence: ") + data["computation"]["chi2_test"]["confidence"] * 100 + "%";
  report_div.appendChild(confidence_section);
  let freedom_section = document.createElement("p");
  freedom_section.innerHTML = _("Degrees of freedom: ") + data["computation"]["chi2_test"]["DOF"];
  freedom_section.title= _("Observations number minus parameters number")
  report_div.appendChild(freedom_section);
  let test_section = document.createElement("p");
  test_section.innerHTML = _("Test: ") +
      to_fixed(parseFloat(data["computation"]["chi2_test"]["min"]), nb_decimals) + " < " +
      to_fixed(parseFloat(data["computation"]["sigma_0_final"]), nb_decimals) + " < " +
      to_fixed(parseFloat(data["computation"]["chi2_test"]["max"]), nb_decimals) + " ?";
  report_div.appendChild(test_section);
  let test_result_section = document.createElement("p");
  test_result_section.innerHTML = _("Test passed: ") + bool(chi2OK) + _("!") + emoticon;
  report_div.appendChild(test_result_section);
  if (data["computation"]["inverted_matrix"]){
    let big_ellipsoid_section = document.createElement("p");
    big_ellipsoid_section.innerHTML=_('Biggest ellipsoid semi axis:') + " " + to_fixed(parseFloat(data["computation"]["biggest_ellips"]), nb_decimals) + "m";
    big_ellipsoid_section.id="biggest_ellips";
    report_div.appendChild(big_ellipsoid_section);
  }
}

//------------------------------------------------------------------------------
//--------------- Display init coord in html table
//------------------------------------------------------------------------------
function show_coord_init(){
  let report_div = create_title_section('coord_init',_('Initial coordinates'),_('Init'));

  // Create table tag
  let table = document.createElement("table");
  table.id = "init_coord_table";
  table.classList.add("report_tables");

  // Create header table
  let header_conf = get_header_conf("init_coord", data["computation"]["inverted_matrix"],data["computation"]["use_vertical_deflection"])
  let thead = make_html_header(header_conf);
  let columns_count = header_conf.length;
  table.appendChild(thead);

  let tbody = document.createElement("tbody");

  for (let i = 0; i < nb_pts; i++) {
    let pt = all_pts[i];
    let new_tr = add_pt_row(header_conf, pt, i);
    tbody.appendChild(new_tr);
  }
  table.appendChild(tbody);

  let div = document.createElement("div");
  div.classList.add("div_buttons");
  report_div.appendChild(div);
  report_div.appendChild(table);

  // Add sort reset and copy buttons
  let reset_button = create_sort_reset_button(table.id);
  let export_button = create_export_button([table.id], _('Initial coordinates'));
  let select_button = create_select_button(table.id);

  div.appendChild(reset_button);
  div.appendChild(export_button);
  div.appendChild(select_button);
}

//---------------------------------------------------------------------------------------
//--------------- Create and fill Observations table
//---------------------------------------------------------------------------------------
function show_obs(){
    console.time("create_obs_table");
    let report_div = create_title_section('obs',_('Observations'),_('Obs'));

    // Create table tag
    let table = document.createElement("table");
    table.id = "observations_table";
    table.classList.add("report_tables");

    // Create header table
    let header_conf = get_header_conf("observations", data["computation"]["inverted_matrix"],data["computation"]["use_vertical_deflection"],data["config"]["compute_type"])
    let thead = make_html_header(header_conf);
    let columns_count = header_conf.length;
    table.appendChild(thead);

    let tbody = document.createElement("tbody");

    let last_file_id = -1;
    let index_init = 0;
    for (let i = 0; i < all_obs.length; i++){
      let obs=all_obs[i];
      index_init++;

      // if new file, insert filename row
      if (obs.file_id !== last_file_id){

        last_file_id = obs.file_id;

        let new_tr = document.createElement("tr");

        new_tr.classList.add("filename");
        let td_init = document.createElement("td");
        let span = document.createElement("span");
        span.classList.add("value");
        span.innerHTML = index_init;
        td_init.appendChild(span);
        new_tr.appendChild(td_init);

        let td_filename = document.createElement("td");
        td_filename.colSpan = columns_count - 1;
        let file_link = document.createElement("a");
        if (obs.file_id>=0)
        {
          file_link.href = all_files[obs.file_id];
          file_link.setAttribute('download', all_files[obs.file_id]);
          file_link.innerHTML = all_files[obs.file_id];
        } else {
          file_link.innerHTML = _('Without file');
        }
        td_filename.appendChild(file_link);
        new_tr.appendChild(td_filename);
        index_init++;
        tbody.appendChild(new_tr);
      }
      let new_tr = add_obs_row(header_conf, obs,index_init,data["computation"]["inverted_matrix"]);
      tbody.appendChild(new_tr);
    }

    table.appendChild(tbody);

    let div = document.createElement("div");
    div.classList.add("div_buttons");
    report_div.appendChild(div);
    report_div.appendChild(table);

    // Add sort reset and copy buttons
    let reset_button = create_sort_reset_button(table.id);
    let export_button = create_export_button([table.id], _('Observations'));
    let select_button = create_select_button(table.id);

    div.appendChild(reset_button);
    div.appendChild(export_button);
    div.appendChild(select_button);

    console.timeEnd("create_obs_table");
}

//---------------------------------------------------------------------------------------
//--------------- Create and fill residuals charts
//---------------------------------------------------------------------------------------
function show_repart_residuals(){
  console.time("show_repart_residuals");
  let report_div = create_title_section("repart_residuals",_("Residual distribution"),_("Res"));

  //prepare residuals histogram -----------------------
  const residuals_class_width = 0.5;
  let all_residuals_class_labels=["<-3\u03C3"];
  let all_residuals_class_val={};
  all_residuals_class_val["all"]=[0];
  all_residuals_class_val["std"]=[0];
  for (let i = 0; i < exist_type.length; i++){
    all_residuals_class_val[exist_type[i]]=[0];
  }

  for (let i = 0; i < 6 / residuals_class_width - 1; i++){
    let x = -3 + (i + 1) * residuals_class_width;
    all_residuals_class_labels.push(to_fixed(x, 1) + "\u03C3");
    all_residuals_class_val["all"].push(0);
    all_residuals_class_val["std"].push(all_active_obs.length * residuals_class_width / Math.sqrt(2 * Math.PI) * Math.exp(- x * x / 2) );
    for (let i = 0; i < exist_type.length; i++){
      all_residuals_class_val[exist_type[i]].push(0);
    }
  }
  all_residuals_class_labels.push(">3\u03C3");
  all_residuals_class_val["all"].push(0);
  all_residuals_class_val["std"].push(0);
  for (let i = 0; i < exist_type.length; i++){
    all_residuals_class_val[exist_type[i]].push(0);
  }

  let min_dist = 10000;
  let max_dist = 0;
  for (let i = 0; i < all_active_obs.length; i++){
    let active_obs=all_active_obs[i];
    let class_num = Math.round((active_obs.normalized_residual + 3) / residuals_class_width);
    class_num = Math.min(class_num, all_residuals_class_labels.length - 1);
    class_num = Math.max(class_num, 0);
    all_residuals_class_val["all"][class_num]+=1;
    //prepare datas for residuals vs distance charts -----------------------
    let type=type_obs[active_obs.code];
    if (type_dist_chart.includes(type)){
      if (active_obs.obs_length > max_dist)
        max_dist = active_obs.obs_length;
      if ((active_obs.obs_length > 0.1) && (active_obs.obs_length < min_dist))
        min_dist = active_obs.obs_length;
    }

    if (!(type==="cint")){
      all_residuals_class_val[type][class_num]+=1;
    }
  }
  min_dist-=0.001;
  max_dist+=0.001;

  let all_residuals_class_config = {
    type: 'bar',
    data: {
      labels: all_residuals_class_labels,
      datasets: [{
          label: _("Standard"),
          fill: false,
          backgroundColor: bgColor["std"],
          borderColor: bdColor["std"],
          pointRadius: 0,
          data: all_residuals_class_val["std"],
          type: 'line'
        },
        {
          label: _("All residuals"),
          backgroundColor: bgColor["all"],
          borderColor: bdColor["all"],
          pointRadius: 0,
          data: all_residuals_class_val["all"],
        },
      ]
    },
    options: {
      responsive: true,
      title: {
        display: true,
        text: _("Normalized residuals distribution")
      },
      showTooltips: false,
      hover: {
        mode: 'nearest',
        intersect: true
      },
      scales: {
        xAxes: [{
          display: true,
          scaleLabel: {
            display: false,
          }
        }],
        yAxes: [{
          display: true,
          scaleLabel: {
            display: false,
          }
        }]
      }
    }
  };

  const dist_chart_num_steps = 10;
  const dist_chart_start_step = min_dist;
  const dist_chart_factor_step = Math.pow((max_dist / dist_chart_start_step), 1 / (dist_chart_num_steps - 1));

  let dist_residuals_class_val={};
  let all_dists = [];
  let dist_graph=false;

  for (const type of exist_type){
    if (type_dist_chart.includes(type)){//No dist chart for coord and den obs
      dist_graph=true;
      dist_residuals_class_val[type]={};
      dist_residuals_class_val[type]["val"]=[];
      dist_residuals_class_val[type]["abs"]=[];
      dist_residuals_class_val[type]["num"]=[];
      dist_residuals_class_val[type]["et"]=[];//ecart type
    }
  }

  if (dist_graph){
    var dist_residuals_class_labels = [];
    let dist = dist_chart_start_step;
    for (let i = 0; i < dist_chart_num_steps + 1; i++){
      all_dists.push(dist);
      dist_residuals_class_labels.push("<" + to_fixed(dist, 1) + "m");
      for (const type of exist_type){
        if (type_dist_chart.includes(type)){
          dist_residuals_class_val[type]["val"].push(0);
          dist_residuals_class_val[type]["abs"].push(0);
          dist_residuals_class_val[type]["num"].push(0);
          dist_residuals_class_val[type]["et"].push(0);
        }
      }
      dist *= dist_chart_factor_step;
    }

    for (let i = 0; i < all_active_obs.length; i++){
      let active_obs=all_active_obs[i];
      let type=type_obs[active_obs.code];
      let class_num = 0;
      for (let j = 0; j < dist_chart_num_steps - 1; j++){
        if (active_obs.obs_length > all_dists[j])
          class_num++;
      }
      if (type_dist_chart.includes(type)){
        dist_residuals_class_val[type]["val"][class_num]+= (active_obs.normalized_residual);
        dist_residuals_class_val[type]["abs"][class_num] += Math.abs(active_obs.normalized_residual);
        dist_residuals_class_val[type]["num"][class_num] += 1;
      }
    }

    for (let i = 0; i < dist_chart_num_steps; i++){
      for (const type of exist_type){
        if (type_dist_chart.includes(type)){
          if (dist_residuals_class_val[type]["num"][i] > 0){
            dist_residuals_class_val[type]["val"][i] /= dist_residuals_class_val[type]["num"][i];
            dist_residuals_class_val[type]["abs"][i] /= dist_residuals_class_val[type]["num"][i];
          }
        }
      }
    }

    for (let i = 0; i < all_active_obs.length; i++){
      let active_obs=all_active_obs[i];
      let type=type_obs[active_obs.code];
      let class_num = 0;
      for (let j = 0; j < dist_chart_num_steps - 1; j++) {
        if (active_obs.obs_length > all_dists[j]){
          class_num++;
        }
      }
      if (type_dist_chart.includes(type)){
        dist_residuals_class_val[type]["et"][class_num] += Math.abs(active_obs.normalized_residual - dist_residuals_class_val[type]["val"][class_num]);
      }
    }

    for (let i = 0; i < dist_chart_num_steps; i++){
      for (const type of exist_type){
        if (type_dist_chart.includes(type)){
          if (dist_residuals_class_val[type]["num"][i] > 0){
            dist_residuals_class_val[type]["et"][i]/= dist_residuals_class_val[type]["num"][i];
          }
        }
      }
    }
    var data2graph_dist = [];
    var dist_residuals_all = [];
  }

  let data2graph_type = [];
  for (const type of exist_type){
    data2graph_type.push({
      label: _(full_name_type[type]),
      backgroundColor: bgColor[type],
      borderColor: bdColor[type],
      pointRadius: 0,
      data: all_residuals_class_val[type],
    });
    if (dist_graph){
      if (type_dist_chart.includes(type)){
        data2graph_dist.push({
          label: _(full_name_type[type]),
          backgroundColor: bgColor[type],
          borderColor: bdColor[type],
          pointRadius: 0,
          data: dist_residuals_class_val[type]["abs"],
        })
        dist_residuals_all.push([dist_residuals_class_val[type]["val"], dist_residuals_class_val[type]["num"], dist_residuals_class_val[type]["et"], dist_residuals_class_val[type]["abs"]]);
      }
    }
  }

  //prepare type-based normalized residual distribution charts -----------------------
  let all_residuals_class_config_type = {
    type: 'bar',
    data: {
      labels: all_residuals_class_labels,
      datasets: data2graph_type
    },
    options: {
      responsive: true,
      title: {
        display: true,
        text: _("Type-based normalized residuals distribution")
      },
      showTooltips: false,
      hover: {
        mode: 'nearest',
        intersect: true
      },
      scales: {
        xAxes: [{
          display: true,
          scaleLabel: {
            display: false,
          }
        }],
        yAxes: [{
          display: true,
          scaleLabel: {
            display: false,
          }
        }]
      }
    }
  };

  //prepare residuals vs distance charts -----------------------
  if (dist_graph){
    var dist_residuals_class_config_type = {
      type: 'bar',
      data: {
        labels: dist_residuals_class_labels,
        datasets: data2graph_dist
      },
      options: {
        responsive: true,
        title: {
          display: true,
          text: _("Average distance-relative normalized absolute residuals distribution")
        },
        showTooltips: true,
        tooltips: {
          callbacks: {
            label: function(tooltipItem, data) {
              return " Abs" + _(": ") + to_fixed(dist_residuals_all[tooltipItem.datasetIndex][3][tooltipItem.index], 2) + "\u03C3  | NoAbs" + _(": ") +
                to_fixed(dist_residuals_all[tooltipItem.datasetIndex][0][tooltipItem.index], 2) + "\u03C3 +/-" +
                to_fixed(dist_residuals_all[tooltipItem.datasetIndex][2][tooltipItem.index], 2) +
                "\u03C3 | NbObs" + _(": ") + dist_residuals_all[tooltipItem.datasetIndex][1][tooltipItem.index];
              //return tooltipItem.index+" "+tooltipItem.datasetIndex;//Object.keys(tooltipItem);
              //return data.datasets[0].data[0];//Object.keys(data);
            }
          }
        },
        hover: {
          mode: 'nearest',
          intersect: true
        },
        scales: {
          xAxes: [{
            display: true,
            scaleLabel: {
              display: false,
            }
          }],
          yAxes: [{
            display: true,
            scaleLabel: {
              display: false,
            },
            ticks: {
              callback: function(value, index, values) {
                return to_fixed(value, 2) + "\u03C3";
              },
            }
          }]
        }
      }
    };
  }

  // Create table tag
  let table1 = document.createElement("table");
  table1.id = "residuals_charts";

  let tr1 = document.createElement("tr");

  let td1 = document.createElement("td");
  let canvas1 = document.createElement("canvas");
  canvas1.id = "canvas_residuals_chart";

  let td2 = document.createElement("td");
  let canvas2 = document.createElement("canvas");
  canvas2.id = "canvas_residuals_chart_type";

  td1.appendChild(canvas1);
  td2.appendChild(canvas2);
  tr1.appendChild(td1);
  tr1.appendChild(td2);
  table1.appendChild(tr1);

  let residuals_repart_section = document.getElementById("repart_residuals");
  residuals_repart_section.after(table1);

  // Create table tag
  let table2 = document.createElement("table");
  table2.id = "dist_residuals_charts_type";

  let tr2 = document.createElement("tr");

  if (dist_graph){
    let td3 = document.createElement("td");
    var canvas3 = document.createElement("canvas");
    canvas3.id = "canvas_dist_residuals_chart_type";

    td3.appendChild(canvas3);
    tr2.appendChild(td3);
  }

  table2.appendChild(tr2);
  table1.after(table2);

  let ctx1 = canvas1.getContext("2d");
  let ctx2 = canvas2.getContext("2d");
  ctx1.canvas.width = 400;
  ctx1.canvas.height = 300;
  ctx2.canvas.width = 400;
  ctx2.canvas.height = 300;

  let myNewChart2 = new Chart(ctx1, all_residuals_class_config);
  let myNewChart3 = new Chart(ctx2, all_residuals_class_config_type);
  if (dist_graph){
    let ctx3 = canvas3.getContext("2d");
    ctx3.canvas.width = 800;
    ctx3.canvas.height = 300;
    let myNewChart4 = new Chart(ctx3, dist_residuals_class_config_type);
  }
  console.timeEnd("show_repart_residuals");
}

//---------------------------------------------------------------------------------------
//--------------- Suggestions
//---------------------------------------------------------------------------------------
function show_sugg(){
  let report_div = create_title_section("propositions_sugg_aleatoires",_("Suggestions"),_("Sugg"));
  const sum_sigma_type_instrum={};
  const num_type_instrum = {};
  const red_type_instrum={};
  const nb_red_type_instrum = {};
  for (const type of exist_type){
    sum_sigma_type_instrum[type]={all:0};
    num_type_instrum[type]={all:0};
    red_type_instrum[type]={all:0};
    nb_red_type_instrum[type]={all:0};
  }
  for (let i = 0; i < all_active_obs.length; i++){
    const obs=all_active_obs[i];
    const type=type_obs[obs.code];
    if (type && !(type==="cint")){
      const file_id=obs.file_id;
      if (sum_sigma_type_instrum[type][file_id]===undefined){
         sum_sigma_type_instrum[type][file_id]=0;
         num_type_instrum[type][file_id]=0;
         red_type_instrum[type][file_id]=0;
         nb_red_type_instrum[type][file_id]=0;
      }
      sum_sigma_type_instrum[type][file_id]+=Math.abs(obs.normalized_residual)*(obs.obs_redondancy/100);
      sum_sigma_type_instrum[type]["all"]+=Math.abs(obs.normalized_residual)*(obs.obs_redondancy/100);
      num_type_instrum[type][file_id]+=1;
      num_type_instrum[type]["all"]+=1;
      red_type_instrum[type][file_id]+=obs.obs_redondancy/100;
      red_type_instrum[type]["all"]+=obs.obs_redondancy/100;
      if (obs.obs_redondancy > 80){
        nb_red_type_instrum[type][file_id]+=1;
        nb_red_type_instrum[type]["all"]+=1;
      }
    }
  }
  let red_tot=0
  let sum_sigma_n=0
  for (const type of exist_type){
    red_tot+=red_type_instrum[type]["all"];
    sum_sigma_n+=sum_sigma_type_instrum[type]["all"];
  }
  const mu=sum_sigma_n/parseFloat(data["computation"]["sigma_0_final"]);

  let redundancy_section = document.createElement("h4");
  redundancy_section.innerHTML = _("System redundancy") + _(": ") + to_fixed(red_tot, 0);
  redundancy_section.title = _("Sum of partial redundancies corresponding to the degree of freedom of the system");

  let redundancy_paragraph = document.createElement("p");
  redundancy_paragraph.innerHTML = _("Observations sigmas may be multiplied by:");

  let sugg_section = document.getElementById("propositions_sugg_aleatoires");
  sugg_section.after(redundancy_section);
  redundancy_section.after(redundancy_paragraph);
  let ul = document.createElement('ul');
  let instrum="all"
  for (let i = 0; i < exist_type.length; i++){
    const type=exist_type[i];
    if (num_type_instrum[type][instrum]){
      const li=get_data_suggestions(instrum,type,red_type_instrum,nb_red_type_instrum,num_type_instrum,sum_sigma_type_instrum,red_tot,mu);
      ul.appendChild(li);
    }
  }
  redundancy_paragraph.appendChild(ul);

  //suggestions per file
  let ul_intrum = document.createElement('ul');
  ul_intrum.id="suggestions_data";

  for (let instrum in all_files){
    let li = document.createElement('li');
    ul_intrum.appendChild(li);
    li.innerHTML += all_files[instrum];
    let ul2 = document.createElement('ul');
    for (const type of exist_type){
      if (num_type_instrum[type][instrum]){
        const li2=get_data_suggestions(instrum,type,red_type_instrum,nb_red_type_instrum,num_type_instrum,sum_sigma_type_instrum,red_tot,mu)
        ul2.appendChild(li2);
        li.appendChild(ul2);
      }
    }
  }

  report_div=add_button(report_div,"suggestions",ul_intrum,'block','toggleButtons("suggestions_data","suggestions_button",_("Show suggestions per file"),_("Hide suggestions per file"))')
  toggleButtons("suggestions_data","suggestions_button",_("Show suggestions per file"),_("Hide suggestions per file"));
}

//---------------------------------------------------------------------------------------
//--------------- Create and fill biggest residuals
//---------------------------------------------------------------------------------------
function show_biggest_residuals(){
  let report_div = create_title_section("biggest_residuals",_("Biggest residuals"),_("Big"));
  let at_least_one_big = false;

  // Create table tag
  let table = document.createElement("table");
  table.id = "biggest_residuals_table";
  table.classList.add("report_tables");

  // Create header table
  let header_conf = get_header_conf("biggest_residuals", data["computation"]["inverted_matrix"],data["computation"]["use_vertical_deflection"])
  let thead = make_html_header(header_conf);
  table.appendChild(thead);

  let tbody = document.createElement("tbody");
  all_active_obs.sort(residualSortFunction);

  for (let i = 0; i < Math.min(max_biggest_residuals, all_active_obs.length); i++)
    if (residual_is_big(all_active_obs[i])){
      at_least_one_big = true
      let new_tr = add_obs_row(header_conf, all_active_obs[i],i,data["computation"]["inverted_matrix"]);
      tbody.appendChild(new_tr);
    }

  if(at_least_one_big){
    table.appendChild(tbody);

    let div = document.createElement("div");
    div.classList.add("div_buttons");
    report_div.appendChild(div);
    report_div.appendChild(table);

    // Add sort reset and copy buttons
    const reset_button = create_sort_reset_button(table.id);
    const export_button = create_export_button([table.id], _('Biggest residuals'));
    const select_button = create_select_button(table.id);

    div.appendChild(reset_button);
    div.appendChild(export_button);
    div.appendChild(select_button);
  }else{ //If no big residual
    const no_big = document.createElement("h5");
    no_big.innerHTML = _("No big residuals");
    report_div.appendChild(no_big);
  }
}

//---------------------------------------------------------------------------------------
//--------------- Create and fill similarities table
//---------------------------------------------------------------------------------------
function show_G0(){
  let report_div = create_title_section("g_0",_("G0"),_("G0"));

  // Create table tag
  let table = document.createElement("table");
  table.id = "g0";
  table.classList.add("report_tables");

  // Create header table
  let header_conf = get_header_conf("g0s", data["computation"]["inverted_matrix"],data["computation"]["use_vertical_deflection"]);
  let thead = make_html_header(header_conf);
  table.appendChild(thead);

  let tbody = document.createElement("tbody");

  for (let i = 0; i < all_g0.length; i++){
    let g0=all_g0[i];
    let sigma=0;
    let value=0;
    let unitFactor=0;

    for (const [key, val] of Object.entries(g0.params)){
      for (const [key2, val2] of Object.entries(val)){
        if (key2=="sigma"){
          sigma=parseFloat(val2);
        }else if (key2=="value"){
          value=parseFloat(val2);
        }else if (key2=="unit_factor"){
          unitFactor=parseFloat(val2);
        }
      }
    }

    let value_unit=value/unitFactor
    let sigma_unit=sigma/unitFactor*10000

    //New line
    let new_tr = document.createElement("tr");
    new_tr.setAttribute('class',parite[i % 2]);

    //Case Point
    let td_point=document.createElement("td");
    td_point.innerHTML=g0.name;
    new_tr.appendChild(td_point);

    //Case Tour number
    let td_number=document.createElement("td");
    td_number.innerHTML=g0.num;
    new_tr.appendChild(td_number);

    //Case Value
    let td_value=document.createElement("td");
    let attribute = ['post','\u0020'+'g']
    td_value.appendChild(format_value(value_unit, false, nb_decimals, attribute, true));
    new_tr.appendChild(td_value);

    //Case Sigma
    let td_sigma=document.createElement("td");
    let attribute2 = ['post','\u0020'+'dmgon']
    td_sigma.appendChild(format_value(sigma_unit, false, nb_decimals_mini, attribute2, true));
    new_tr.appendChild(td_sigma);

    //Case Active obs
    let td_active_obs=document.createElement("td");
    td_active_obs.innerHTML=g0.nbr_active_obs;
    new_tr.appendChild(td_active_obs);

    tbody.appendChild(new_tr);
  }

  table.appendChild(tbody);

  let div = document.createElement("div");
  div.classList.add("div_buttons");
  report_div.appendChild(div);
  report_div.appendChild(table);

  // Add sort reset and copy buttons
  let reset_button = create_sort_reset_button(table.id);
  let export_button = create_export_button([table.id], _('Equality constraints'));
  let select_button = create_select_button(table.id);

  div.appendChild(reset_button);
  div.appendChild(export_button);
  div.appendChild(select_button);
}

//---------------------------------------------------------------------------------------
//--------------- Create and fill similarities table
//---------------------------------------------------------------------------------------
function show_similarities(){
  let report_div = create_title_section("similarities",_("Similarities"),_("Sim"));

  // Create table tag
  let table = document.createElement("table");
  table.id = "sim";
  table.classList.add("report_tables");

  // Create header table
  let header_conf = get_header_conf("similarities", data["computation"]["inverted_matrix"],data["computation"]["use_vertical_deflection"]);
  let thead = make_html_header(header_conf);
  table.appendChild(thead);

  let tbody = document.createElement("tbody");

  const triplet_types = {
    11: "cart obs",
    12: "angl obs"
  };

  for (let i = 0; i < all_basc.length; i++){
    if (all_basc[i].geocentric) continue;
    let basc = all_basc[i];
    let origin = basc.origin;
    let pos = origin["coord_compensated_cartesian"];
    let matrix = basc["params_rot"]["R_global2instr"];
    let obs_type = triplet_types[basc["triplet_type"]]; //+tooltips + traduc
    let params = basc["params"];
    if (data["computation"]["inverted_matrix"])
    {
      Object.keys(params).forEach((p) =>
        {
          if (p.includes("_Ra_"))
            params.Rx = params[p];
          if (p.includes("_Rb_"))
            params.Ry = params[p];
          if (p.includes("_Rc_"))
            params.Rz = params[p];
        });
    }

    //First line
    let new_tr = document.createElement("tr");
    new_tr.setAttribute('class',parite[i % 2]);

    //Case file
    let td_file=document.createElement("td");
    td_file.classList.add("name");
    td_file.setAttribute('rowspan',2);
    let a_file=document.createElement("a");
    a_file.setAttribute('href',all_files[basc["observations"][0].file_id]);
    a_file.innerHTML=all_files[basc["observations"][0].file_id]
    td_file.appendChild(a_file);
    new_tr.appendChild(td_file);

    //Case name
    let td_name=document.createElement("td");
    td_name.classList.add("name");
    td_name.setAttribute('rowspan',4);
    td_name.innerHTML=basc.name;
    new_tr.appendChild(td_name);

    //Case vertical
    let td_vert=document.createElement("td");
    td_vert.setAttribute('rowspan',2);
    td_vert.title=_("Is subframe z forced to be aligned with vertical?");
    td_vert.innerHTML=(basc.vertical?_("Verticalized"):_("Not verticalized"))
    new_tr.appendChild(td_vert);

    //Case T
    let td_T=document.createElement("td");
    td_T.title=_("Transformation between subframe and global cartesian frame");
    td_T.innerHTML="T";
    new_tr.appendChild(td_T);

    //Cases value T
    let td_value_T1=document.createElement("td");
    td_value_T1.innerHTML=to_fixed(parseFloat(pos[0]), nb_decimals);
    new_tr.appendChild(td_value_T1);
    let td_value_T2=document.createElement("td");
    td_value_T2.innerHTML=to_fixed(parseFloat(pos[1]), nb_decimals);
    new_tr.appendChild(td_value_T2);
    let td_value_T3=document.createElement("td");
    td_value_T3.innerHTML=to_fixed(parseFloat(pos[2]), nb_decimals);
    new_tr.appendChild(td_value_T3);

    if (data["computation"]["inverted_matrix"]) // empty line for sigmas
        new_tr.appendChild(document.createElement("td"));

    tbody.appendChild(new_tr);

    //Second line
    let new_tr2 = document.createElement("tr");
    new_tr2.setAttribute('class',parite[i % 2]);

    //Case R
    let td_R=document.createElement("td");
    td_R.title=_("Transformation between subframe and global cartesian frame");
    td_R.innerHTML="R";
    td_R.setAttribute('rowspan',3);
    new_tr2.appendChild(td_R);

    //Cases value R
    let td_value_R0=document.createElement("td");
    td_value_R0.innerHTML=to_fixed(parseFloat(matrix[0]), nb_decimals);
    new_tr2.appendChild(td_value_R0);
    let td_value_R1=document.createElement("td");
    td_value_R1.innerHTML=to_fixed(parseFloat(matrix[1]), nb_decimals);
    new_tr2.appendChild(td_value_R1);
    let td_value_R2=document.createElement("td");
    td_value_R2.innerHTML=to_fixed(parseFloat(matrix[2]), nb_decimals);
    new_tr2.appendChild(td_value_R2);

    if (data["computation"]["inverted_matrix"])
    {
      let td_value_sigma=document.createElement("td");
      td_value_sigma.innerHTML=to_fixed(parseFloat(params.Rx.sigma)/parseFloat(params.Rx.unit_factor), nb_decimals);
      let span_value = document.createElement("span");
      span_value.setAttribute('post', '\u0020'+params.Rx.unit_str);
      td_value_sigma.appendChild(span_value);
      new_tr2.appendChild(td_value_sigma);
    }

    tbody.appendChild(new_tr2);

    //Third line
    let new_tr3 = document.createElement("tr");
    new_tr3.setAttribute('class',parite[i % 2]);

    //Cases value nb_obs
    let td_nb_obs=document.createElement("td");
    td_nb_obs.setAttribute('rowspan',2);
    td_nb_obs.title=_("Number and nature of active observations");
    td_nb_obs.innerHTML=all_basc[i].nbr_active_obs + " " + obs_type;
    new_tr3.appendChild(td_nb_obs);

    //Case deflection
    let td_def=document.createElement("td");
    td_def.title=_("Angle between vertical and sub-frame z");
    td_def.innerHTML=_("Deflection");
    new_tr3.appendChild(td_def);

    //Cases value R 2nd row
    let td_value_R3=document.createElement("td");
    td_value_R3.innerHTML=to_fixed(parseFloat(matrix[3]), nb_decimals);
    new_tr3.appendChild(td_value_R3);
    let td_value_R4=document.createElement("td");
    td_value_R4.innerHTML=to_fixed(parseFloat(matrix[4]), nb_decimals);
    new_tr3.appendChild(td_value_R4);
    let td_value_R5=document.createElement("td");
    td_value_R5.innerHTML=to_fixed(parseFloat(matrix[5]), nb_decimals);
    new_tr3.appendChild(td_value_R5);

    if (data["computation"]["inverted_matrix"])
    {
      let td_value_sigma=document.createElement("td");
      td_value_sigma.innerHTML=to_fixed(parseFloat(params.Ry.sigma)/parseFloat(params.Ry.unit_factor), nb_decimals);
      let span_value = document.createElement("span");
      span_value.setAttribute('post', '\u0020'+params.Ry.unit_str);
      td_value_sigma.appendChild(span_value);
      new_tr3.appendChild(td_value_sigma);
    }

    tbody.appendChild(new_tr3);

    //Fourth line
    let new_tr4 = document.createElement("tr");
    new_tr4.setAttribute('class',parite[i % 2]);

    //Case value deflection
    let td_value_def=document.createElement("td");
    td_value_def.title=_("Angle between vertical and sub-frame z")

    td_value_def.innerHTML=to_fixed(parseFloat(basc.ang_to_vert), nb_decimals);
    let span_value = document.createElement("span");
    span_value.setAttribute('post', '\u0020'+data["computation"]["unit_name"]);
    td_value_def.appendChild(span_value);
    new_tr4.appendChild(td_value_def);

    tbody.appendChild(new_tr4);

    //Cases value R 3rd row
    let td_value_R6=document.createElement("td");
    td_value_R6.innerHTML=to_fixed(parseFloat(matrix[6]), nb_decimals);
    new_tr4.appendChild(td_value_R6);
    let td_value_R7=document.createElement("td");
    td_value_R7.innerHTML=to_fixed(parseFloat(matrix[7]), nb_decimals);
    new_tr4.appendChild(td_value_R7);
    let td_value_R8=document.createElement("td");
    td_value_R8.innerHTML=to_fixed(parseFloat(matrix[8]), nb_decimals);
    new_tr4.appendChild(td_value_R8);

    if (data["computation"]["inverted_matrix"])
    {
      let td_value_sigma=document.createElement("td");
      td_value_sigma.innerHTML=to_fixed(parseFloat(params.Rz.sigma)/parseFloat(params.Rz.unit_factor), nb_decimals);
      let span_value = document.createElement("span");
      span_value.setAttribute('post', '\u0020'+params.Rz.unit_str);
      td_value_sigma.appendChild(span_value);
      new_tr4.appendChild(td_value_sigma);
    }

    tbody.appendChild(new_tr4);
  }

  table.appendChild(tbody);

  let div = document.createElement("div");
  div.classList.add("div_buttons");
  report_div.appendChild(div);
  report_div.appendChild(table);


  // Add sort reset and copy buttons
  let export_button = create_export_button([table.id], _('Similarities'));
  let select_button = create_select_button(table.id);

  div.appendChild(export_button);
  div.appendChild(select_button);
}

//---------------------------------------------------------------------------------------
//--------------- Create and fill Axis table
//---------------------------------------------------------------------------------------
function show_axes(){
  let report_div = create_title_section("axis",_("Axes"),_("Axes"));

  const all_axis=["Aa","Ab","Ac"];
  //One table per axis
  for (let i = 0; i < all_axes.length; i++){
    let p = document.createElement("p");
    let axe = all_axes[i];
    let origin = all_axes[i].origin;
    let pos = origin["coord_compensated_cartesian"];

    let prec={};//precision by axis
    for (let i = 0; i < all_axis.length; i++){
      let axis=all_axis[i];
      const key_axis = Object.keys(axe.params).find(key => key.match(axe.name+'_'+axis+'.*'));
      if (data["computation"]["inverted_matrix"]) {
        prec[axis]=" &plusmn; "+to_fixed(axe.params[key_axis].sigma, nb_decimals);
      }else{
        prec[axis]="";
      }
    }

    const key_a = Object.keys(axe.params).find(key => key.match(axe.name+'_Aa.*'));
    const key_b = Object.keys(axe.params).find(key => key.match(axe.name+'_Ab.*'));
    const key_c = Object.keys(axe.params).find(key => key.match(axe.name+'_Ac.*'));

    // Create title tag
    let table_title = document.createElement("h4");
    table_title.innerHTML = _("Axis")+' <a href="' + all_files[axe["observations"][0].file_id] + '" download>' + all_files[axe["observations"][0].file_id] + '</a>'+_(" on point ")+axe.name;

    let div = document.createElement("div");
    div.classList.add("div_buttons");

    // Create table tag
    let table = document.createElement("table");
    table.id = axe.name;
    table.classList.add("axis_param_table");

    // Add export button
    let export_button = create_export_button([table.id], axe.name);
    let select_button = create_select_button(table.id);

    div.appendChild(export_button);
    div.appendChild(select_button);

    //Axis Header line
    let new_tr=document.createElement("tr");
    let new_th=document.createElement("th");
    new_th.setAttribute('colspan',4);
    new_th.innerHTML=_("Axis parameterization");
    new_tr.appendChild(new_th);
    table.appendChild(new_tr);

    //a axis line
    let tr_a=document.createElement("tr");
    let td_a=document.createElement("td");
    td_a.setAttribute('colspan',2);
    td_a.innerHTML=to_fixed(axe.params[key_a].value, nb_decimals) + prec["Aa"];
    tr_a.appendChild(td_a);
    let td_a2=document.createElement("td");
    tr_a.appendChild(td_a2);
    let td_a3=document.createElement("td");
    td_a3.innerHTML=to_fixed(pos[0], nb_decimals);
    tr_a.appendChild(td_a3);
    table.appendChild(tr_a);

    //b axis line
    let tr_b=document.createElement("tr");
    let td_b=document.createElement("td");
    td_b.setAttribute('colspan',2);
    td_b.innerHTML=to_fixed(axe.params[key_b].value, nb_decimals) + prec["Ab"];
    tr_b.appendChild(td_b);
    let td_b2=document.createElement("td");
    td_b2.innerHTML=" * λ + ";
    tr_b.appendChild(td_b2);
    let td_b3=document.createElement("td");
    td_b3.innerHTML=to_fixed(pos[1], nb_decimals);
    tr_b.appendChild(td_b3);
    table.appendChild(tr_b);

    //c axis line
    let tr_c=document.createElement("tr");
    let td_c=document.createElement("td");
    td_c.setAttribute('colspan',2);
    td_c.innerHTML=to_fixed(axe.params[key_c].value, nb_decimals) + prec["Ac"];
    tr_c.appendChild(td_c);
    let td_c2=document.createElement("td");
    tr_c.appendChild(td_c2);
    let td_c3=document.createElement("td");
    td_c3.innerHTML=to_fixed(pos[2], nb_decimals);
    tr_c.appendChild(td_c3);
    table.appendChild(tr_c);

    //Target Header line
    let tr_tg=document.createElement("tr");
    let th_tg=document.createElement("th");
    th_tg.innerHTML=_("Target ID");
    th_tg.addClass="name";
    tr_tg.appendChild(th_tg);
    let th_ab=document.createElement("th");
    th_ab.innerHTML=_("Abscissa");
    tr_tg.appendChild(th_ab);
    let th_rd=document.createElement("th");
    th_rd.innerHTML=_("Radius");
    tr_tg.appendChild(th_rd);
    let th_pos=document.createElement("th");
    th_pos.innerHTML=_("Positions");
    tr_tg.appendChild(th_pos);
    table.appendChild(tr_tg);

    //Line per target
    for (let j = 0; j < axe.targets.length; j++){
      let target=axe.targets[j];
      const key_l = Object.keys(axe.params).find(key => key.match(axe.name+'_st.*_T'+target.num+'_l'));
      const key_r = Object.keys(axe.params).find(key => key.match(axe.name+'_st.*_T'+target.num+'_r'));

      let tg_tr=document.createElement("tr");
      //Target case
      let td_tg=document.createElement("td");
      td_tg.setAttribute('field','from');
      td_tg.innerHTML=target.num;
      tg_tr.appendChild(td_tg);
      //Abcsissa case
      let td_ab=document.createElement("td");
      td_ab.innerHTML = to_fixed(axe.params[key_l].value, nb_decimals);
      tg_tr.appendChild(td_ab);
      //Radius case
      let td_rd=document.createElement("td");
      td_rd.innerHTML = to_fixed(axe.params[key_r].value, nb_decimals);
      tg_tr.appendChild(td_rd);
      //Position case
      let td_pos=document.createElement("td");
      td_pos.innerHTML=target.axisObs.length;
      tg_tr.appendChild(td_pos);
      table.appendChild(tg_tr);
    }

    p.appendChild(table_title)
    p.appendChild(div)
    p.appendChild(table);
    report_div.appendChild(p);
  }
}

//---------------------------------------------------------------------------------------
//--------------- Create and fill equality constraints table
//---------------------------------------------------------------------------------------
function show_equality(){
  let report_div = create_title_section("equality",_("Equality constraints"),_("Equality"));

  // Create table tag
  let table = document.createElement("table");
  table.id = "eq";
  table.classList.add("report_tables");

  // Create header table
  let header_conf = get_header_conf("equalities", data["computation"]["inverted_matrix"],data["computation"]["use_vertical_deflection"]);
  let thead = make_html_header(header_conf);
  table.appendChild(thead);

  let tbody = document.createElement("tbody");

  for (let i = 0; i < all_eq.length; i++){
    let eq = all_eq[i];
    let type=type_obs[eq.eq_type];
    let sigma=0;
    let value=0;

    for (const [key, val] of Object.entries(eq.params)){
      for (const [key2, val2] of Object.entries(val)){
        if (key2=="sigma"){
          sigma=val2;
        }else if (key2=="value"){
          value=val2;
        }
      }
    }

    //New line
    let new_tr = document.createElement("tr");
    new_tr.setAttribute('class',parite[i % 2]);

    //Case file
    let td_file=document.createElement("td");
    td_file.classList.add("name");
    let a_file=document.createElement("a");
    a_file.setAttribute('href',all_files[eq.file_id]);
    a_file.innerHTML=all_files[eq.file_id]
    td_file.appendChild(a_file);
    new_tr.appendChild(td_file);

    //Case type
    let td_type=document.createElement("td");
    td_type.innerHTML=type;
    new_tr.appendChild(td_type);

    //Case value
    let td_value=document.createElement("td");
    let attribute = ['post','\u0020'+ 'm'];
    td_value.appendChild(format_value(value, false, nb_decimals, attribute, true));
    new_tr.appendChild(td_value);

    //Case sigma
    let td_sigma=document.createElement("td");
    let attribute2 = ['post','\u0020'+ 'mm'];
    td_sigma.appendChild(format_value(sigma* 1000, false, nb_decimals_mini, attribute2, true));
    new_tr.appendChild(td_sigma);

    //Case Active obs
    let td_active_obs=document.createElement("td");
    td_active_obs.innerHTML=eq.nbr_active_obs;
    new_tr.appendChild(td_active_obs);

    tbody.appendChild(new_tr);
  }

  table.appendChild(tbody);

  let div = document.createElement("div");
  div.classList.add("div_buttons");
  report_div.appendChild(div);
  report_div.appendChild(table);

  // Add sort reset and copy buttons
  let reset_button = create_sort_reset_button(table.id);
  let export_button = create_export_button([table.id], _('Equality constraints'));
  let select_button = create_select_button(table.id);

  div.appendChild(reset_button);
  div.appendChild(export_button);
  div.appendChild(select_button);
}

//---------------------------------------------------------------------------------------
//--------------- Create and fill Compensated coordinates table
//---------------------------------------------------------------------------------------
function show_coord_comp(){
  let report_div = create_title_section("coord_comp",_("Compensated coordinates"),_("Comp"));

  // Create table tag
  let table = document.createElement("table");
  table.id = "coord_comp_table";
  table.classList.add("report_tables");

  // Create header table
  let header_conf = get_header_conf("coord_comp_table", data["computation"]["inverted_matrix"],data["computation"]["use_vertical_deflection"])
  let thead = make_html_header(header_conf);
  let columns_count = header_conf.length;
  table.appendChild(thead);

  let tbody = document.createElement("tbody");

  for (let i = 0; i < nb_pts; i++){
    let pt = all_pts[i];
    let new_tr = add_pt_row(header_conf, pt, i);
    tbody.appendChild(new_tr);
  }

  table.appendChild(tbody);

  let coord_comp_section = document.getElementById("coord_comp");
  coord_comp_section.after(table);

  // Add sort reset and copy buttons
  let reset_button = create_sort_reset_button(table.id);
  let export_button = create_export_button([table.id], _('Compensated coordinates'));
  let select_button = create_select_button(table.id);
  let div = document.createElement("div");
  div.classList.add("div_buttons");
  div.appendChild(reset_button);
  div.appendChild(export_button);
  div.appendChild(select_button);
  table.parentNode.insertBefore(div, table);
}

//---------------------------------------------------------------------------------------
//--------------- Create and fill ellispoids table
//---------------------------------------------------------------------------------------
function show_ellips(){
  let report_div = create_title_section("ellips",_("Confidence ellipsoids"),_("Ell"));

  // Create table tag
  let table = document.createElement("table");
  table.id = "ellips_table";
  table.classList.add("report_tables");

  // Create header table
  let header_conf = get_header_conf("ellips", data["computation"]["inverted_matrix"],data["computation"]["use_vertical_deflection"])
  let thead = make_html_header(header_conf);
  table.appendChild(thead);

  let tbody = document.createElement("tbody");

  for (let i = 0; i < nb_pts; i++){
    let pt = all_pts[i];

    let new_tr = document.createElement("tr");
    let td_name= document.createElement("td");
    let td_axis= document.createElement("td");
    let td_az= document.createElement("td");
    let td_tilt= document.createElement("td");

    //fill pt line
    let pt_code = pt_code_name2html(pt.code_name);
    let attribute = ['pre', pt_code_name2html(pt.code_name)+'\u0020']
    let val=pt.name;
    let nb_param=1;//Number of param of point to know how many line per point
    if (pt.params){
      nb_param=Object.keys(pt.params).length;
    }
    td_name.setAttribute('rowspan',nb_param);
    td_name.appendChild(format_value(val, false, false, attribute));

    if (!(pt.comment === "")||(pt.comment === "*")){
      td_name,comment_tooltip=generate_comment_tooltip(pt.comment,td_name,false);
      let sp_tooltip = document.createElement("span");
      sp_tooltip.classList.add("tooltip");
      let tooltiptext = document.createElement("span");
      tooltiptext.classList.add("tooltiptext");
      tooltiptext.appendChild(comment_tooltip);
      sp_tooltip.appendChild(tooltiptext);
      td_name.appendChild(sp_tooltip);
    }

    new_tr.setAttribute('class',parite[i % 2]);
    new_tr.appendChild(td_name);

    if (!pt.params){//No param -> point fixed
      td_axis.innerText='-';
      td_az.innerText='-';
      td_tilt.innerText='-';
      new_tr.appendChild(td_axis);
      new_tr.appendChild(td_az);
      new_tr.appendChild(td_tilt);
      table.appendChild(new_tr);
    }else if (pt.dimension === 1){//1D point
      let val_axis=parseFloat(pt.ellips.axes[0][0]) * 1000;
      td_axis.appendChild(format_value(val_axis, false, nb_decimals_mini+1));
      td_az.innerText='-';
      let val_tilt=parseFloat(pt.ellips.axes[0][2]);
      td_tilt.appendChild(format_value(val_tilt, false, nb_decimals_mini+1));
      new_tr.appendChild(td_axis);
      new_tr.appendChild(td_az);
      new_tr.appendChild(td_tilt);
      table.appendChild(new_tr);
    }else{//other case
      for (let j = 0; j < nb_param; j++){
        let val_axis=parseFloat(pt.ellips.axes[j][0]) * 1000;
        td_axis.appendChild(format_value(val_axis, false , nb_decimals_mini+1));
        let val_az=parseFloat(pt.ellips.axes[j][1]);
        td_az.appendChild(format_value(val_az, false, nb_decimals));
        let val_tilt=parseFloat(pt.ellips.axes[j][2]);
        td_tilt.appendChild(format_value(val_tilt, false, nb_decimals));

        //one line and 3 cases per param
        new_tr.appendChild(td_axis);
        new_tr.appendChild(td_az);
        new_tr.appendChild(td_tilt);
        table.appendChild(new_tr);
        new_tr = document.createElement("tr");
        new_tr.setAttribute('class',parite[i % 2]);
        td_axis= document.createElement("td");
        td_az= document.createElement("td");
        td_tilt= document.createElement("td");
      }
    }
  }

  let div = document.createElement("div");
  div.classList.add("div_buttons");
  report_div.appendChild(div);
  report_div.appendChild(table);

  // Add copy buttons
  let export_button = create_export_button([table.id], _('Confidence ellipsoids'));
  let select_button = create_select_button(table.id);
  div.appendChild(export_button);
  div.appendChild(select_button);
}

//---------------------------------------------------------------------------------------
//--------------- Create and fill intervals table
//---------------------------------------------------------------------------------------
function show_intervals(){
  let report_div = create_title_section("interv",_("Confidence semi-intervals"),_("Inter"));

  // Create table tag
  let table = document.createElement("table");
  table.id = "interv_table";
  table.classList.add("report_tables");

  // Create header table
  let header_conf = get_header_conf("interv", data["computation"]["inverted_matrix"],data["computation"]["use_vertical_deflection"]);
  let thead = make_html_header(header_conf);
  table.appendChild(thead);

  let tbody = document.createElement("tbody");

  for (let i = 0; i < nb_pts; i++) {
    let pt = all_pts[i];
    let new_tr = add_pt_row(header_conf, pt, i);
    tbody.appendChild(new_tr);
  }

  table.appendChild(tbody);
  let div = document.createElement("div");
  div.classList.add("div_buttons");
  report_div.appendChild(div);
  report_div.appendChild(table);

  let reset_button = create_sort_reset_button(table.id);
  let export_button = create_export_button([table.id],  _("Confidence semi-intervals"));
  let select_button = create_select_button(table.id);
  div.appendChild(reset_button);
  div.appendChild(export_button);
  div.appendChild(select_button);
}

//---------------------------------------------------------------------------------------
//--------------- Show displacements in case of Monte-Carlo simulation
//---------------------------------------------------------------------------------------
function show_displacements(){
  let report_div = create_title_section("displacements",_("Points displacements simulation"),_("Disp"));

  // Create paragraph
  let disp_parag = document.createElement("p");
  disp_parag.innerHTML = _("For ") + parseInt(data["computation"]["nbr_iterations"]) + _(" simulations:");
  report_div.appendChild(disp_parag);


  // Create table tag
  let table = document.createElement("table");
  table.id = "displa";
  table.classList.add("report_tables");

  // Create header table
  let header_conf = get_header_conf("displa", data["computation"]["inverted_matrix"],data["computation"]["use_vertical_deflection"]);
  let thead = make_html_header(header_conf);
  table.appendChild(thead);

  let tbody = document.createElement("tbody");
  for (let i = 0; i < nb_pts; i++) {
    let pt = all_pts[i];
    let new_tr = add_pt_row(header_conf, pt, i);
    tbody.appendChild(new_tr);
  }
  table.appendChild(tbody);

  let div = document.createElement("div");
  div.classList.add("div_buttons");
  report_div.appendChild(div);
  report_div.appendChild(table);

  let reset_button = create_sort_reset_button(table.id);
  let export_button = create_export_button([table.id], _("Points displacements simulation"));
  let select_button = create_select_button(table.id);

  div.appendChild(reset_button);
  div.appendChild(export_button);
  div.appendChild(select_button);
}

//---------------------------------------------------------------------------------------
//--------------- Show footer
//---------------------------------------------------------------------------------------
function show_footer(){
  let p = document.createElement("p");
  p.textContent = data["COMP3D_COPYRIGHT"]+ " - " + data["COMP3D_LICENSE"] + " - ";
  p.classList.add("footer");

  let link = document.createElement("a");
  link.href = src_link;
  link.innerHTML = src_link;
  p.appendChild(link);

  let report = document.getElementById("main");
  report.appendChild(p);
}

//------------------------------------------------------------------------------
// Wrtting parts loading function
//------------------------------------------------------------------------------
function showComp3Djson(data){
    let name = data["config"]["name"];
    let title_tag = document.getElementById("title").innerHTML = name;

    nb_decimals = parseInt(data["config"]["nb_digits"]);
    nb_decimals_mini = Math.max(nb_decimals - 3, 0);

    const lang = data["config"]["lang"];
    if (lang in translations)
        current_dict= translations[lang];

    // Parsing data from json file
    if (data["points"]){
        for (const [key, val] of Object.entries(data["points"])) {
            all_pts.push(val);
            if (val.dimension !== 1) {
                three_dimension=true;
            }
            all_pts_name[key]=val;
            all_pts[all_pts.length - 1].name = key;
            if (val["stations"] && Object.keys(val["stations"]).length !== 0) {
                for (const [key2, val2] of Object.entries(val["stations"])) {
                    for (const [key3, val3] of Object.entries(val2["observations"])) {
                      val3.num = val2.num;
                      all_obs.push(val3);
                    }
                    if (val2["type"] === "bascule") {
                        all_basc.push(val2);
                        all_basc[all_basc.length - 1].name = key;
                        all_basc[all_basc.length - 1].origin = val;
                    }else if (val2["type"] === "axis") {
                        all_axes.push(val2);
                        all_axes[all_axes.length - 1].name = key;
                        all_axes[all_axes.length - 1].origin = val;
                    }else if (val2["type"] === "hz_unknown") {
                        all_g0.push(val2);
                        all_g0[all_g0.length - 1].name = key;
                    }
                }
            }
        }
    }
    if (data["other_stations"]){
        for (const [key, val] of Object.entries(data["other_stations"])) {
            if (val["type"] === "eq") {
              all_eq.push(val);
            }
            for (const [key3, val3] of Object.entries(val["observations"])) {
              all_obs.push(val3);
            }
        }
    }
    if (data["computation"]){
        if (data["computation"]["internal_constraints_obs"]){
            for (const [key, val] of Object.entries(data["computation"]["internal_constraints_obs"])) {
                all_obs.push(val);
            }
        }
        for (const obs of all_obs){
            if ((obs.active)&&(data["computation"]["inverted_matrix"]===(obs.obs_redondancy!==undefined))){ //obs not used in internal constraints have no redondancy
                all_active_obs.push(obs);
                exist[type_obs[obs.code]] = true;
            }
        }
    } else {
      return; //no computation, nothing to do
    }

    nb_pts=all_pts.length;
    all_pts.sort(pointSortFunction);
    all_obs.sort(obsSortFunction);
    all_files = data["all_data_files"];
    var nbFiles = 0;
    for (let o in all_files) ++nbFiles;

    // Create html table of content (toc)

    let toc_div = document.createElement("div");
    toc_div.id = "table_of_content";
    let tocmini_div = document.createElement("div");
    tocmini_div.id = "table_of_content_mini";
    let sidebar = document.getElementById("sideBar");

    let title_a = document.createElement("div");
    title_a.setAttribute("href", "#top");
    let title_h = document.createElement("h1");
    title_h.innerHtml = title;

    title_a.appendChild(title_h);
    toc_div.appendChild(title_a);
    tocmini_div.appendChild(title_a);
    sidebar.appendChild(toc_div);
    sidebar.appendChild(tocmini_div);

    let report = document.createElement("div");
    report.id = "report";

    let main_div = document.getElementById("main");

    let notify_div = document.createElement("div");
    notify_div.id = "notify";
    notify_div.classList.add("hide_notif");
    main.appendChild(notify_div);
    main.appendChild(report);

    // Each function displaying a section
    show_version();
    show_info_work();
    if (data["points"]){
        if (data["config"]["display_map"]){
            createMap();
        }
    }
    show_info_calc();
    if (data["points"]){
        if ((data["config"]["compute_type"] === 0) && (data["computation"]["all_sigma0"].length>0)){
          if (data["computation"]["sigma_0_final"]!==null){
            show_evol_sigma0();
          }
          show_chi2();
        }
        for (let type in exist){
          if (exist[type] && !(type==="cint")){
            exist_type.push(type);
          }
        }
        show_coord_init();
        show_obs();
        if (exist["hz"]){
          show_G0();
        }
        if (data["config"]["compute_type"] === 0){
            show_repart_residuals();
        }
        if ((data["config"]["compute_type"] === 0) && (data["computation"]["inverted_matrix"])){
            show_sugg();
        }
        if (data["config"]["compute_type"] === 0){
            show_biggest_residuals();
        }
        if (all_basc.length > 0){
            show_similarities();
        }
        if (all_axes.length > 0){
            show_axes();
        }
        if (all_eq.length > 0){
            show_equality();
        }
        if ((data["computation"]["compensation_done"]) && (data["config"]["compute_type"] === 0)){
            show_coord_comp();
        }
        if (data["computation"]["inverted_matrix"]){
            if (three_dimension){
                show_ellips();
            }
            show_intervals();
        }
        if (data["config"]["compute_type"] === 2){//Monte Carlo
            show_displacements();
        }
    }
    show_footer();
}

document.addEventListener("DOMContentLoaded", function(event) {
  document.title='... - Comp3D';//update window title ASAP
  document.getElementById("title").innerHTML="";
  document.getElementById("title").className="spinner";

  let script_data = document.createElement("script");
  script_data.onload = function () {
    title=data["config"]["name"]; //update window title ASAP
    if (title==="")
      title=data["config_file"].replace(/^.*[\\\/]/, '');
    document.title=title+" - Comp3D";
    setTimeout(() => {
      showComp3Djson(data);
      document.getElementById("title").classList.remove("spinner");
    }, 0);
  };
  script_data.src = data_file;
  script_data.type = "text/javascript";
  document.head.appendChild(script_data);
});
